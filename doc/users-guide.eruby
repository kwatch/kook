%
% phpkook = rbkook = pykook = false
% if ENV['PROJECT']
%   case ENV['PROJECT']
%   when 'kook', 'phkook';  project = 'phKook'
%   when 'rook', 'rbkook';  project = 'rbKook'
%   when 'pook', 'pykook';  project = 'pyKook'
%   else raise "*** internal error: ENV['PROJECT']=#{ENV['PROJECT']}"
%   end
% else
%   case Dir.pwd
%   when /\b(php|phkook)\b/;     project = 'phKook'
%   when /\b(ruby|rbkook)\b/;    project = 'rbRook'
%   when /\b(python|pykook)\b/;  project = 'pyKook'
%   else raise "*** could not detect target project."
%   end
% end
% case project
% when "phKook";  phkook = true;  tuple = %w[PHP    php phkook kk]
% when "rbKook";  rbkook = true;  tuple = %w[Ruby   rb  rbkook kk]
% when "pyKook";  pykook = true;  tuple = %w[Python py  pykook kk]
% end
% lang, suffix, command, short_command = tuple
% LANG, SUFFIX, COMMAND, SHORT_COMMAND = tuple
% PROJECT = project
% BASENAME = basename = 'Kookbook'
% BOOKNAME = bookname = basename + '.' + suffix
% PHP, RUBY, PYTHON = phpkook, rbkook, pykook
%
% def error
%   ex = StandardError.new("*** internal error")
%   ex.set_backtrace(caller())
%   raise ex
% end
%
.=title:	[%= PROJECT %] Users' Guide
.?revision:	$Rev$
.?release:	$Release$
.#.?author:	makoto kuwata <kwa(at)kuwata-lab.com>
.?stylesheet:	docstyle.css
.#.?stylesheet:	html-css.css
.#.?lastupdate:	$Date: $


.$ Preface		| preface*

{{<[%= PROJECT %]|http://www.kuwata-lab.com/kook/>}} is a software build tool such as Make, {{<Rake|http://rake.rubyforge.org/>}}, {{<Ant|http://ant.apache.org/>}}, {{<SCons|http://www.scons.org/>}} or {{<Cook|http://www.canb.auug.org.au/~millerp/cook/cook.html>}}.
It is implemented in [%= LANG %] and runs any platform [%= LANG %] support.
Basic command (copy, move, rename, mkdir, ...) is also implemented in [%= LANG %] and allows you to execute platform-depended command.

[%= PROJECT %] liken build process to cooking.  Input file is called 'ingredient', output is 'product', task is 'recipe', build file is 'cookbook'.
[%= PROJECT %] generates products from ingredients according to recipes.
You describe products, ingredients, and recipes in cookbook.

Features:

.* Impremented in pure Rython and runs any platform which Python supports.
.* Input file (called 'cookbook') is named '[%= BOOKNAME %]', which is equivarent to 'Makefile' of Make or 'build.xml' of Ant.
.* Cookbook's format is pure Python. You can write any Python code in kookbook.
.* Support command-line scripting framework.

% if PHP
Kook is implemented in PHP5 because exception is supported only in PHP5 and not supported in PHP4.
You need to install PHP5 before using Kook.
% end

{{!Caution! [%= PROJECT %] is currently under experimental. It means that the design and specification of [%= PROJECT %] may change without prior notice.!}}



.$$ Table of Contents	 | toc*

.<<< users-guide.toc


.$ Cookbook  		| cookbook

This sectipn describes how to write cookbook.


.$$ Recipes		| cookbook-recipes

Cookbook should contains some recipes.
Each recipes are described with function and function decorators.

.* {{,@recipe,}} decorator represents that this is a recipe definition.
   If function is not decorated by {{,@recipe,}}, it is not regarded as recipe.
.* {{,@product(),}} decorator represents filename which is generated by the recipe.
   This takes only an argument.
.* {{,@ingreds(),}} decorator represents filenames which are required to generate product.
   This can take several arguments.
.* function {{,file_xxx(),}} represents how to generate the product from ingredients.
   It is called as recipe function.
   .#Name of recipe function should be {{,file_xxx(),}} or {{,task_xxx(),}} and it should take an argument.
   Recipe function name should be start with 'file_' prefix if it generates file product.
.* function description is regarded as recipe description.

In cookbook, some helper functions provided by [%= PROJECT %] are available.
% if PHP
For exaple, function 'k_sys()' invokes OS-depend command.
% elsif RUBY
For exaple, function 'sys()' invokes OS-depend command.
% elsif PYTHON
For exaple, function '{{,system(),}}' invokes OS-depend command.
% else error() end
See {{<References|#refs>}} for details about helper functions.

The following is an example of recipe definitions in cookbook.

.? [%= BOOKNAME %]: Compile hello.c so that to generate 'hello' command.
.-------------------- [%= BASENAME %]1.[%= suffix %]
# product "hello" depends on "hello.o".
{{*@recipe*}}
{{*@product("hello")*}}
{{*@ingreds("hello.o")*}}
def file_hello(c):
    """generates hello command"""           # recipe description
    system("gcc -g -o hello hello.o")

# product "hello.o" depends on "hello.c" and "hello.h".
{{*@recipe*}}
{{*@product("hello.o")*}}
{{*@ingreds("hello.c", "hello.h")*}}
def file_hello_o(c):
    """compile 'hello.c' and 'hello.h'"""   # recipe description
    system("gcc -g -c hello.c")
.--------------------

[%= PROJECT %] also provides short-notation. See the following example which is equivarent to the above, or see {{<this section|#topic-short-notation>}} for details.

.? Example of Short-notation
.--------------------
# product "hello" depends on "hello.o".
{{*@recipe("hello", ["hello.o"])*}}
def file_hello(c):
    """generates hello command"""           # recipe description
    system("gcc -g -o hello hello.o")

# product "hello.o" depends on "hello.c" and "hello.h".
{{*@recipe("hello.o", ["hello.c", "hello.h"])*}}
def file_hello_o(c):
    """compile 'hello.c' and 'hello.h'"""   # recipe description
    system("gcc -g -c hello.c")
.--------------------

The following is an example of invoking {{,[%= COMMAND %],}} command.
Command-line option '{{,-l,}}' shows recipes which have description.
It means that recipes which have description are public recipes.
Command-line option '{{,-L,}}' shows all recipes.

.? command-line example
.==================== [%= BASENAME %]1.recipe.result
sh> [%= COMMAND %] -l
Properties:

Task recipes:

File recipes:
  hello               : generates hello command
  hello.o             : compile 'hello.c' and 'hello.h'

(Tips: you can set 'kook_default_product' variable in your kookbook.)

sh> [%= COMMAND %] hello
### ** hello.o (recipe=file_hello_o)
$ gcc -g -c hello.c
### * hello (recipe=file_hello)
$ gcc -g -o hello hello.o
.====================

[%= PROJECT %] also provides {{,[%= SHORT_COMMAND %],}} command which is equivarent to {{,[%= COMMAND %],}}, because {{,[%= COMMAND %],}} is too long to type many times :)
See {{<this section|#topic-short-command>}} for details.



.$$ Timestamp and content              | cookbook-timestamp

[%= PROJECT %] checks both timestamp and content of files (= products, ingredients).
.* If product is older than ingredients, that recipe will be executed.
.* If product is newer than or have the same timestamp as ingredients, that recipe will not be executed.
.* If recipe of ingredient is executed but content of ingredient is not changed, then recipe of product will not be executed and product will be 'touched'.
.* If you specify command-line option '{{,-F,}}', these rules are ignored and all recipes are executed forcedly.

.==================== [%= BASENAME %]1.product2.result
sh> [%= COMMAND %] hello               # 1st time
### ** hello.o (recipe=file_hello_o)
$ gcc -g -c hello.c
### * hello (recipe=file_hello)
$ gcc -g -o hello hello.o

sh> [%= COMMAND %] hello               # 2nd time
                               # nothing, because hello is already created.

sh> touch hello.c              # touch hello.c
sh> [%= COMMAND %] hello               # 3rd time
### ** hello.o (recipe=file_hello_o)
$ gcc -g -c hello.c            # compiled, because hello.c is newer than hello.o.
### * hello (recipe=file_hello)
$ {{*touch hello   # skipped*}}      # skipped, because content of hello.o is not changed.

sh> [%= COMMAND %] {{*-F*}} hello            # 4th time (forcedly)
### ** hello.o (recipe=file_hello_o)
$ gcc -g -c hello.c
### * hello (recipe=file_hello)
$ gcc -g -o hello hello.o
.====================



.$$ Product and Ingredients		| cookbook-prod

% if PHP
Product and ingredient names are referable as local variable in recipe's 'method*:' part.
.* Variable '$product' represents product.
.* Variable '$ingreds' represents ingredients.
.* Variable '$ingred' represents the first item of ingredients (= $ingreds[0]).
% elsif RUBY
Product and ingredient names are referable as instance variable in recipe's 'method*:' part.
.* Variable '@product' represents product.
.* Variable '@ingreds' represents ingredients.
.* Variable '@ingred' represents the first item of ingredients (= @ingreds[0]).
% elsif PYTHON
Product and ingredient names are referable as property of recipe function's argument.
.* Property 'c.product' represents product.
.* Property 'c.ingreds' represents ingredients.
.* Property 'c.ingred' represents the first item of ingredients (= c.ingreds[0]).
% else error() end

.? [%= BOOKNAME %]: Use {{,c.product,}} and {{,c.ingreds,}}
.-------------------- [%= BOOKNAME %]2.[%= SUFFIX %]
# product "hello" depends on "hello.o".
@recipe
@product("hello")
@ingreds("hello.o")
def file_hello(c):
    """generates hello command"""
    system("gcc -g -o %s %s" % ({{*c.product*}}, {{*c.ingred*}}))
    # or system("gcc -g -o %s %s" % ({{*c.product*}}, {{*c.ingreds[0]*}}))
    # or system({{*c%*}}"gcc -g -o {{*$(product)*}} {{*$(ingreds[0])*}}")

# product "hello.o" depends on "hello.c" and "hello.h".
@recipe
@product("hello.o")
@ingreds("hello.c", "hello.h")
def file_hello_o(c):
    """compile 'hello.c' and 'hello.h'"""
    system("gcc -g -c %s" % {{*c.ingred*}})
    # or system("gcc -g -c %s" % {{*c.ingreds[0]*}})
    # or system({{*c%*}}"gcc -g -c {{*$(ingred)*}}")
.--------------------

.? command-line example
.==================== [%= BASENAME %]2.product.result
sh> [%= COMMAND %] hello
### ** hello.o (recipe=file_hello_o)
$ gcc -g -c hello.c
### * hello (recipe=file_hello)
$ gcc -g -o hello hello.o
.====================



% if PYTHON
[%= PROJECT %] provides convenience way to embed variables into string literal.
For example, the followings are equivarent.

.--------------------
system("gcc -g -o %s %s" % (c.product, c.ingreds[0]))    # or c.ingred
system({{*c%*}}"gcc -g -o $(product) $(ingreds[0])")           # or $(ingred)
.--------------------

You can write local or global variables in {{,$(),}} as well as {{,product,}} or {{,ingreds,}}.

.--------------------
CC     = 'gcc'             # global variable

@recipe
@product("hello")
@ingreds("hello.o")
def file_hello(c):
    CFLAGS = '-g -Wall'    # local variable
    system(c%"{{*$(CC)*}} {{*$(CFLAGS)*}} -o $(product) $(ingreds[0])")
.--------------------

% end



.$$ Specific recipe and generic recipe		| cook-grecipe

Specific recipe is a recipe which is combined to a certain file.
Product name of specific recipe is a concrete file name.

% if PHP
Generic recipe is a recipe which is combined to a pattern of file name.
Product name of generic recipe is a pattern with metacharacter or regular expression used by preg_match().
% elsif RUBY
Generic recipe is a recipe which is combined to a pattern of file name.
Product name of generic recipe is a pattern with metacharacter or regular expression.
% elsif PYTHON
Generic recipe is a recipe which is combined to a pattern of file name.
Product name of generic recipe is a pattern with metacharacter or regular expression.
% else error() end

[%= PROJECT %] converts file name pattern into regular expression.
% if PHP
For example, file name pattern '*.o' is coverted to regular expression '/^(.*)\.o$/',
and '*.??.txt' to '/^(.*)\.(.)(.)\.txt$/'.
% elsif RUBY
For example, file name pattern {{,'*.o',}} is coverted to regular expression {{,/^(.*)\.o$/,}},
and {{,'*.??.txt',}} to {{,/^(.*)\.(.)(.)\.txt$/,}}.
% elsif PYTHON
For example:
.* {{,'*.o',}} will be coverted into {{,r'^(.*?)\.o$',}}.
.* {{,'*.??.txt',}} will be converted into to {{,r'^(.*?)\.(..)\.txt$',}}.
% else error() end

% if PHP
Matched strings with metacharacter ('*' or '?') are accessable by '$(1)', '$(2)', ... in recipe definition and local variable '$m' in 'method*:' part.
% elsif RUBY
Matched strings with metacharacter ('*' or '?') are accessable by '$(1)', '$(2)', ... in recipe definition and instance variable '@m' in 'method*:' part.
% elsif PYTHON
Matched strings with metacharacter ('*' or '?') are accessable by {{,$(1),}}, {{,$(2),}}, ... in {{,@ingreds(),}} decorator.
% else error() end

.? [%= BOOKNAME %]: Compile hello.c so that to generate 'hello' command.
.-------------------- [%= BASENAME %]3.[%= SUFFIX %]
## specific recipe
@recipe
@product("hello")
@ingreds("hello.o")
def file_hello(c):
    """generates hello command"""
    system(c%"gcc -g -o $(product) $(ingred)")
    # or system("gcc -g -o %s %s" % (c.product, c.ingred))
    # or system("gcc -g -o %s %s" % (c.product, c.ingreds[0]))

## generic recipe
@recipe
@product("{{**.o*}}")        # or @product(re.compile(r'^(.*?)\.o$'))
@ingreds("{{*$(1)*}}.c", "{{*$(1)*}}.h")
def file_ext_o(c):
    """compile '*.c' and '*.h'"""
    system(c%"gcc -g -c {{*$(1)*}}.c")
    # or system("gcc -g -c %s.c" % {{*c.m[1]*}})
    # or system("gcc -g -c %s" % c.ingred)
.--------------------

.? command-line example
.==================== [%= BOOKNAME %]3.grecipe.result
sh> [%= COMMAND %] -l
Properties:

Task recipes:

File recipes:
  hello               : generates hello command
  {{**.o*}}                 : compile '*.c' and '*.h'

(Tips: you can set 'kook_default_product' variable in your kookbook.)

sh> [%= COMMAND %] hello
### ** hello.o (recipe=file_ext_o)
$ gcc -g -c hello.c
### * hello (recipe=file_hello)
$ gcc -g -o hello hello.o
.====================

% if PHP            ; prod_rexp = %q|'/^(.*)\\.o$/'|   ; prod_pat = %q|'*.o'|
% elsif RUBY        ; prod_rexp = %q|/^(.*)\\.o$/|     ; prod_pat = %q|*.o|
% elsif PYTHON      ; prod_rexp = %q|@product(re.compile(r'^(.*)\\.o$'))| ; prod_pat = %q|@product('*.o')|
% else error() end

It is able to specify regular expression instead of filename pattern.
For example, {{,[%= prod_rexp %],}} is available as product instead of {{,[%= prod_pat %],}}.
Grouping in regular expression is referable by {{,$(1),}}, {{,$(2),}}, ... in the same way.

Specific recipe is prior to generic recipe.
For example, recipe 'hello.o' is used and recipe '*.o' is not used to generate 'hello.o' when target product is 'hello.o' in the following example.

.? Specific recipe is prior to generic recipe.
.--------------------
## When target is 'hello.o', this specific recipe will be used.
@recipe
@product("hello.o")
@ingreds("hello.c")
def file_hello_o(c):
    system(c%"gcc -g -O2 -o $(product) $(ingred)")

## This generic recipe will not be used, because specific recipe
## is prior than generic recipe.
@recipe
@product("*.o")
@ingreds("$(1).c", "$(1).h")
def file_o(c):
    system(c%"gcc -g     -o $(product) $(ingred)")
.--------------------



.$$ Conditional Ingredients	| cookbook-if-exists

There may be a case that ingredient file exists or not.
For example, product 'foo.o' depends on 'foo.c' and 'foo.h', while product 'bar.o' depends only on 'bar.c'.

% if PHP || RUBY
In the case, you can use 'toppings:' part which solves the problem.
For example when '{{,toppings:  [hello.h],}}' is specified in recipe definition, [%= PROJECT %] detect dependency as following.
% elsif PYTHON
In this case, you can use {{,if_exists(),}} helper function which resolve the problem.
For example, when {{,if_exists("hello.h"),}} is specified in {{,@ingreds(),}}, [%= PROJECT %] detect dependency as following.
% else error() end
.* If file 'hello.h' exists, product 'hello.o' depends on ingredients 'hello.c' and 'hello.h'.
.* If file 'hello.h' doesn't exist, product 'hello.o' depends on only 'hello.c'.

% if    PHP || RUBY   ;  s = "'toppings:' part"
% elsif PYTHON        ;  s = "{{,if_exists(),}}"
% else error() end
[%= s %] is useful especially when used with generic recipes.

.? [%= BOOKNAME %]: Example of [%= s %]
.-------------------- [%= BASENAME %]4.[%= SUFFIX %]
## specific recipe
@recipe
@product("hello")
@ingreds("hello.o")
def file_hello(c):
    """generates hello command"""
    system(c%"gcc -g -o $(product) $(ingred)")
    # or system("gcc -g -o %s %s" % (c.product, c.ingred))
    # or system("gcc -g -o %s %s" % (c.product, c.ingreds[0]))

## generic recipe
@recipe
@product("*.o")        # or @product(re.compile(r'^(.*?)\.o$'))
@ingreds("$(1).c", {{*if_exists("$(1).h")*}})
def file_hello_o(c):
    """compile '*.c' and '*.h'"""
    system(c%"gcc -g -c $(1).c")
    # or system("gcc -g -c %s.c" % c.m[1])
    # or system("gcc -g -c %s" % c.ingred)
.--------------------

.? command-line example
.==================== [%= BOOKNAME %]4.if_exists.result
sh> [%= COMMAND %] hello
### ** hello.o (recipe=file_hello_o)
$ gcc -g -c hello.c
### * hello (recipe=file_hello)
$ gcc -g -o hello hello.o
.====================



.$$ File Recipe and Task Recipe		| cookbook-recipekind

In [%= PROJECT %], there are two kind of recipe.

.[ File recipe ]
	File recipe is a recipe which generates a file.
	In the other word, product of recipe is a file.
	If product is not generated, recipe execution will be failed.

.[ Task recipe ]
	Task recipe is a recipe which is not aimed to generate files.
	For example, task recipe 'clean' will remove '*.o' files and it doesn't generate any files.

Here is a matrix table of recipe kind.

.? table1: recipe kind matrix
.+================================================================================
			.,  {{*Specific recipe*}}	.,  {{*Generic recipe*}}
{{*File recipe*}}	.,  Specific file recipe 	.,  Generic file recipe
{{*Task recipe*}}	.,  Specific task recipe	.,  Generic task recipe 
.+================================================================================

.#Recipe function of file and task recipes should be started with 'file_' and 'task_' repectively.


[%= PROJECT %] determines recipe kind ('file' or 'task') according the following simple rule:

.* File recipe should start with 'file_' prefix.
.* Task recipe may stat with 'task_' prefix, or NOT decorated by @product().

.+++
<div style="text-align:center">
<img src="fig001.png" alt="How to determine recipe kind?" />
</div>
.+++



.#File recipe function should:
.#.* Be decorated with '@recipe(kind="file")'
.#.* Or be decorated with '@recipe' and '@product()'
.#.#.* Be defined with '@product()' decorator
.#.#.* Or be stated with 'file_' prefix
.#.--------------------
.#{{*@recipe(kind="file")*}}
.#@product('README')        # omissible
.#def README(c):
.#    "wiki2text README.wiki > README"
.#
.#{{*@recipe*}}
.#{{*@product(*}}'README'{{*)*}}
.#def file_readme(c):
.#    "wiki2text README.wiki > README"
.#.--------------------
.#
.#Task recipe function should:
.#.* Be decorated with '@recipe(kind="task")'
.#.* Or be decorated with '@recipe' but not decorated with '@product()'
.#.#.* Be defined without '@product' decorator
.#.#.* Or be started with 'task_' prefix
.#.--------------------
.#{{*@recipe(kind="task")*}}
.#@product('clean')
.#def remove_files(c):
.#    rm_rf("**/*.o")
.#
.#{{*@recipe*}}       # without '@product'
.#def clean(c):
.#    rm_rf("**/*.o")
.#.--------------------

In the following example, task recipe {{,clean,}} is a recipe to delete '*.o' files and is not combined to file 'clean'.
Also task recipe {{,all,}} is a recipe to call recipe of 'hello' and is not combined to file 'all'.

.? [%= BOOKNAME %]: Symbolic recipes
.-------------------- [%= BASENAME %]5.[%= SUFFIX %]
## file recipe
@recipe
@product("hello")
@ingreds("hello.o")
def file_hello(c):
    """generates hello command"""
    system(c%"gcc -g -o $(product) $(ingred)")
    # or system("gcc -g -o %s %s" % (c.product, c.ingred))
    # or system("gcc -g -o %s %s" % (c.product, c.ingreds[0]))

## file recipe
@recipe
@product("*.o")        # or @product(re.compile(r'^(.*?)\.o$'))
@ingreds("$(1).c", if_exists("$(1).h"))
def file_ext_o(c):
    """compile '*.c' and '*.h'"""
    system(c%"gcc -g -c $(1).c")
    # or system("gcc -g -c %s.c" % c.m[1])
    # or system("gcc -g -c %s" % c.ingred)

## task recipe
@recipe
def {{*clean*}}(c):
    """remove '*.o' files"""
    rm_f("*.o")

## task recipe
## (in order to avoid to overwrite 'all()' built-in function,
##  add 'task_' prefix to function name.)
@recipe
@ingreds("hello")
def {{*task_all*}}(c):
    """create all files"""
    pass
.--------------------

.#You can omit '{{,@product("all"),}}' because [%= PROJECT %] will guess product name (= 'all') from recipe function name (= 'task_all').

'{{,[%= command %] -l,}}' will display task recipes and file recipes.

.? command-line example
.==================== [%= BOOKNAME %]5.symrecipe.result
sh> [%= COMMAND %] -l
Properties:

Task recipes:
  clean               : remove by-products
  all                 : cook all products

File recipes:
  hello               : generates hello command
  *.o                 : compile '*.c' and '*.h'

(Tips: you can set 'kook_default_product' variable in your kookbook.)

sh> [%= COMMAND %] all
### *** hello.o (recipe=file_ext_o)
$ gcc -g -c hello.c
### ** hello (recipe=file_hello)
$ gcc -g -o hello hello.o
### * all (recipe=task_all)

sh> [%= COMMAND %] clean
### * clean (recipe=clean)
$ rm -f *.o

sh> ls -F
Kookbook.[%= SUFFIX %]    hello*    hello.c    hello.h
.====================

[%= PROJECT %] have several well-known task name.
Task recipes which product name is in the following list will be got pubilic automatically.
For example, if you have defined 'all' task recipe, it will be displayed by '{{,[%= COMMAND %] -l,}}' even when recicpe function doesn't have any description.

.[ all     ]	create all products
.[ clean   ]	remove by-products
.[ clear   ]	remove all products and by-products
.[ deploy  ]	deploy products
.[ config  ]	configure
.[ setup   ]	setup
.[ install ]	install products
.[ test    ]	do test
.#.[ :main    ]	default recipe to start cooking



.$$ Default Product	| cookbook-default-product

If you set {{,kook_default_product,}} variable, [%= command %] command will use it as default product.

.? [%= BOOKNAME %].yaml: specify default product name
.-------------------- [%= BASENAME %]6.yaml
## global variables
basename = 'hello'
command  = basename
{{*kook_default_product = 'all'*}}     # default product name

## file recipe
@recipe
@product(command)
@ingreds(basename + ".o")
def file_hello(c):
    """generates hello command"""
    system(c%"gcc -g -o $(product) $(ingred)")
    # or system("gcc -g -o %s %s" % (c.product, c.ingred))
    # or system("gcc -g -o %s %s" % (c.product, c.ingreds[0]))

## file recipe
@recipe
@product("*.o")        # or @product(re.compile(r'^(.*?)\.o$'))
@ingreds("$(1).c", if_exists("$(1).h"))
def file_ext_o(c):
    """compile '*.c' and '*.h'"""
    system(c%"gcc -g -c $(1).c")
    # or system("gcc -g -c %s.c" % c.m[1])
    # or system("gcc -g -c %s" % c.ingred)

## task recipe
@recipe
def clean(c):
    """remove '*.o' files"""
    rm_f("*.o")

## task recipe
@recipe
@ingreds(command)
def task_all(c):
    """create all files"""
    pass
.--------------------

If you specify {{,kook_default_product,}}, you can omit target product name in commad-line.

.? command-line example
.==================== [%= BOOKNAME %]6.default.result
sh> [%= COMMAND %]           # you can omit target product name
### *** hello.o (recipe=file_ext_o)
$ gcc -g -c hello.c
### ** hello (recipe=file_hello)
$ gcc -g -o hello hello.o
### * all (recipe=task_all)
.====================



.$$ Properties 				| cookbook-props

.#Property is a pair of name and value.
Property is a global variable which value can be overwrited in command-line option.

% if PHP

You can set properties in cookbook.

You can get property value with '$(name)' notation in property definition and recipe definition.
And properties are accessable as local variable in 'method*' part of recipe definition.

Property name should match to regular expression '/^[_a-zA-Z]\w*$/'.
Notice that period ('.') or hyphen ('-') are not available as property name character.

% elsif RUBY

You can set properties in cookbook.

You can get property value with '$(name)' notation in property definition and recipe definition.
And properties are accessable as instance variable in 'method*' part of recipe definition.

Property name should match to regular expression '/^[_a-zA-Z]\w*$/'.
Notice that period ('.') or hyphen ('-') are not available as property name character.

% elsif PYTHON

Property is defined by {{,prop(),}} function. It takes property name and default value as arguments.

% else error() end


.? [%= BOOKNAME %]: properties
.-------------------- [%= BASENAME %]6.[%= suffix %]
## global variables (not properties)
basename = 'hello'
kook_default_product = 'all'

## properties
CC       = {{*prop('CC', 'gcc')*}}
CFLAGS   = {{*prop('CFLAGS', '-g -O2')*}}
command  = {{*prop('command', basename)*}}

## file recipes
@recipe
@product(command)
@ingreds(basename + ".o")
def file_command(c):
    system(c%"$(CC) $(CFLAGS) -o $(product) $(ingred)")

@recipe
@product("*.o")
@ingreds("$(1).c", if_exists("$(1).h"))
def file_ext_o(c):
    system(c%"$(CC) $(CFLAGS) -c $(ingred)")

## task recipes
@recipe
def clean(c):
    """remove '*.o' files"""
    rm_f("*.o")

@recipe
@ingreds(command)
def task_all(c):
    pass
.--------------------

.#You may prefer to describe property in a line with flow-style.
.#Notice that spaces after colon (':') is required.
.#
.#.--------------------
.#properties:
.#  - { name: basename,  value: hello }
.#  - { name: c_flags,   value: -g -O2 }
.#.--------------------

Properties are shown when command-line option '-l' is specified.

.? command-line example
.==================== [%= BOOKNAME %]6.props2.result
sh> [%= COMMAND %] {{*-l*}}
Properties:
  {{*CC                  : 'gcc'*}}
  {{*CFLAGS              : '-g'*}}
  {{*command             : 'hello'*}}

Task recipes:
  clean               : remove '*.o' files
  all                 : cook all products

File recipes:

(Tips: you can set 'kook_default_product' variable in your kookbook.)
.====================

If you don't specify any property values in command-line, default values are used.

.? command-line example
.==================== [%= BOOKNAME %]6.props3.result
sh> [%= COMMAND %] all
### *** hello.o (recipe=file_ext_o)
$ gcc {{*-g*}} -c hello.c
### ** hello (recipe=file_command)
$ gcc {{*-g*}} -o {{*hello*}} hello.o
### * all (recipe=task_all)
.====================

If you specify property values in command-line, that values are used instead of default values.

.==================== [%= BOOKNAME %]6.props4.result
sh> [%= COMMAND %] {{*--command=foo*}} {{*--CFLAGS='-g -O2 -Wall'*}} all
### *** hello.o (recipe=file_ext_o)
$ gcc {{*-g -O2 -Wall*}} -c hello.c
### ** foo (recipe=file_command)
$ gcc {{*-g -O2 -Wall*}} -o {{*foo*}} hello.o
### * all (recipe=task_all)
.====================

Property file is another way to specify properties.
If you have create property file 'Properties.[%= suffix %]' in current directory, [%= command %] command reads it and set property values automatically.

.? Properties.[%= suffix %]
.-------------------- [%= BASENAME %]6.props5.properties
CFLAGS = '-g -O2 -Wall'
command = 'foo'
.--------------------

Don't forget to write {{,prop({{/'prop-name'/}}, {{/'default-value'/}}),}} in your cookbook even when property file exists.

Result of {{,[%= command %] -l,}} will be changed when property file exists.

.==================== [%= BOOKNAME %]6.props5.result
sh> [%= command %] -l
Properties:
  CC                  : 'gcc'
  CFLAGS              : {{*'-g -O2 -Wall'*}}
  command             : {{*'foo'*}}

Task recipes:
  clean               : remove '*.o' files
  all                 : cook all products

File recipes:

(Tips: you can override properties with '--propname=propvalue'.)
.====================


.#Property file is another way to specify properties.
.#If you have create property file '[%= BOOKNAME %].props' or 'Properties.yaml',
.#[%= COMMAND %] command automatically read it and set properties.
.#
.#.? Property file example
.#.--------------------
.#basename:  hello
.#c_flags:   -g -O2
.#.--------------------
.#
.#Property value can be specified in both YAML format and [%= LANG %] code.
.#If you append '*' in tail of property name, [%= PROJECT %] regard it's value as [%= LANG %] code.
.#% if PHP
.#Property value is to be refered by '$({{/propname/}})' in YAML and by '${{/propname/}}' in [%= LANG %] code.
.#% elsif RUBY
.#Property value is to be refered by '$({{/propname/}})' in YAML and by '@{{/propname/}}' in [%= LANG %] code.
.#% elsif PYTHON
.#% else error() end
.#.#You should use 'expr:' instead of 'value:' to describe property value in [%= LANG %].
.#.#Properties are referenced by '$(propname)' in 'value:' part and referenced as local variables in 'expr:'.
.#
.#.? Property values specified as [%= LANG %] code.
.#.--------------------
.#properties:
.#  - srcdir:      src/main/java
.#  - junit_jar:   lib/junit.jar
.#  - path_elems:  [ '.', {{*$(srcdir)*}}, {{*$(junit_jar)*}} ]
.#% if PHP
.#  - classpath{{***}}:  {{*join(PATH_SEPARATOR, $path_elems)*}}
.#% elsif RUBY
.#  - classpath{{***}}:  {{*@path_elems.join(File::PATH_SEPARATOR)*}}
.#% elsif PYTHON
.#% else error() end
.#
.#recipes:
.#  - product:     :echo
.#    method*: |
.#% if PHP
.#        echo var_export({{*$classpath*}});   #=> '.:src/main/java:lib/junit.jar'
.#% elsif RUBY
.#        p {{*@classpath*}}      #=> ".:src/main/java:lib/junit.jar"
.#% elsif PYTHON
.#% else error() end
.#.--------------------

.#.--------------------
.#properties:
.#  - name:    srcdir
.#    value:   src/main/java
.#  - name:    junit_jar
.#    value:   lib/junit.jar
.#  - name:    classpath_elems
.#    value:   [ '.', {{*$(srcdir)*}}, {{*$(junit_jar)*}} ]
.#  - name:    classpath
.#    {{*expr:*}}    {{*join(PATH_SEPARATOR, $classpath_elems)*}}
.#.--------------------



.$$ Materials		| cookbook-materials

There is an exception in any case.
Assume that you have a file 'optparse.o' which is supplied by other developer and no source.
[%= PROJECT %] will try to find 'optparse.c' and failed in the result.

Using 'kook_materials' variable, you can tell [%= PROJECT %] that 'optparse.o' is not a product.

.? [%= BOOKNAME %]: materials
.-------------------- [%= BASENAME %]8.[%= suffix %]
## global variables (not properties)
basename = 'hello'
kook_default_product = 'all'
{{*kook_materials = ['optparse.o', ]*}}   # specify materials

## properties
CC       = prop('CC', 'gcc')
CFLAGS   = prop('CFLAGS', '-g -O2')
command  = prop('command', basename)

## recipes
@recipe
@product(command)
@ingreds("hello.o", {{*"optparse.o"*}})
def file_command(c):
    system(c%"$(CC) $(CFLAGS) -o $(product) {{*$(ingreds)*}}")

@recipe
@product("*.o")
@ingreds("$(1).c", if_exists("$(1).h"))
def file_ext_o(c):
    system(c%"$(CC) $(CFLAGS) -c $(ingred)")

@recipe
@ingreds(command)
def task_all(c):
    pass
.--------------------

In this example:
.* 'hello.o' will be compiled from 'hello.c'.
.* 'optparse.o' will not be compiled because it is specified as material.

.? command-line example
.==================== [%= BASENAME %]8.materials
sh> [%= COMMAND %] all
### *** hello.o (recipe=file_ext_o)            # only hello.o is compiled
$ gcc -g -O2 -c hello.c
### ** hello (recipe=file_command)
$ gcc -g -O2 -o hello hello.o optparse.o
### * all (recipe=task_all)
.====================



.$$ Command-line options for recipe	| cookbook-spices

You can specify command-line options for certain recipes by {{,@spices(),}} decorator.

.? [%= BOOKNAME %]: command-line options for recipes
.-------------------- [%= BASENAME %]9.[%= suffix %]
## global variables (not properties)
basename = 'hello'
kook_default_product = 'all'
kook_materials = ['optparse.o', ]   # specify materials

## properties
CC       = prop('CC', 'gcc')
CFLAGS   = prop('CFLAGS', '-g -O2')
command  = prop('command', basename)

## recipes
@recipe
@product(command)
@ingreds("hello.o", "optparse.o")
def file_command(c):
    system(c%"$(CC) $(CFLAGS) -o $(product) $(ingreds)")

@recipe
@product("*.o")
@ingreds("$(1).c", if_exists("$(1).h"))
def file_ext_o(c):
    system(c%"$(CC) $(CFLAGS) -c $(ingred)")

@recipe
@ingreds(command)
def all(c):
    pass

@recipe
@ingreds(command)
{{*@spices("-d dir: directory to install (default '/usr/local/bin')",*}}
        {{*"--command=command: command name (default '%s')" % command)*}}
def install(c, {{**args*}}, {{***kwargs*}}):
    {{*opts, rests = kwargs, args*}}
    dir = opts.get('d', '/usr/local/bin')  # get option value
    cmd = opts.get('command', command)     # get option value
    system(c%"sudo cp $(command) $(dir)/$(cmd)")   # or use 'install' command
.--------------------

Command-line options of recipes are displayed by '-l' or '-L' option.

.? command-line example
.==================== [%= BASENAME %]9.spices1.result
sh> [%= COMMAND %] -l
Properties:
  CC                  : 'gcc'
  CFLAGS              : '-g -O2'
  command             : 'hello'

Task recipes:
  all                 : cook all products
  install             : install product
    {{*-d dir                directory to install (default '/usr/local/bin')*}}
    {{*--command=command     command name (default 'hello')*}}

File recipes:

kook_default_product: all

(Tips: 'c%"gcc $(ingreds[0])"' is more natural than '"gcc %s" % c.ingreds[0]'.)
.====================

You can specify command-line options for the recipe.

.==================== [%= BASENAME %]9.spices2.result
sh> [%= COMMAND %] install {{*-d /opt/local/bin --command=hellow*}}
### * install (recipe=task_install)
$ sudo cp hello /opt/local/bin/hellow
Password: *******
.====================

This feature can replace many small scripts with [%= PROJECT %].

The following is an example to show styles of {{,@spices,}} arguments.

.? [%= BOOKNAME %]: example of @spices()
.--------------------
@recipe
@spices("-h:      help",            # short opts (no argument)
        "-f file: filename",        # short opts (argument required)
	"-d[N]:   debug level",     # short opts (optional argument)
	"--help:  help",            # long opts (no argument)
	"--file=file: filename",    # long opts (argument required)
	"--debug[=N]: debug level", # long opts (optional argument)
	)
def echo(c, *args, **kwargs):
    """test of @spices"""
    opts, rests = kwargs, args
    print "opts:", repr(opts)
    print "rests:", repr(rests)
.--------------------

.? result
.====================
sh> [%= COMMAND %] -L
Properties:

Task recipes:
  echo                : test of @spices
    -h                    help
    -f file               filename
    -d[N]                 debug level
    --help                help
    --file=file           filename
    --debug[=N]           debug level

File recipes:

(Tips: you can override properties with '--propname=propvalue'.)

sh> [%= COMMAND %] echo -f hello.c -d99 --help --debug AAA BBB
### * echo (recipe=task_echo)
opts: {'debug': True, 'help': True, 'd': 99, 'f': 'hello.c'}
rests: ('AAA', 'BBB')
.====================



.$ Other features			| topic


.$$ Command-line Scripting Framework	| topic-framework

[%= PROJECT %] supports to create command-line script.

The points are:

.* Add '#!/usr/bin/env [%= COMMAND %] -X' as first line of script (shebang).
.* Add 'kook_desc = "..script description.."'.
.* Define specific task recipes which are regarded as sub-command.


.? 'appsvr' script
.-------------------- appsvr
{{*#!/usr/bin/env pykook -X*}}

from kook.utils import CommandOptionError

{{*kook_desc =*}} "start/stop web application server"

app = prop('app', 'helloworld')

@recipe
@spices("-p port: port number", "-d: debug")
def start(c, *args, **kwargs):
    """start server process"""
    p = kwargs.get("p", 8080)
    d = kwargs.get("d") and "-d" or ""
    _app = args and args[0] or app
    system("nohup python dev_appserver.py -p %s %s %s &" % (p, d, _app))

@recipe
def stop(c):
    """stop server process"""
    system_f("ps auxw | awk '/python dev_appserver.py/ && !/awk/{print $2}' | xargs kill")
.--------------------

.#.? 'hello' script
.#.--------------------
.#{{*#!/usr/bin/env pykook -X*}}
.#
.#from kook.utils import CommandOptionError
.#
.#{{*kook_desc =*}} "example script to show pyKook's CLI framework feature"
.#
.#@recipe
.#def hello(c):
.#    """prints hello world"""      # description of sub-command
.#    echo("Hello world!")
.#
.#@recipe
.#@spices("-u user: username")
.#def sweet(c, *args, **kwargs):
.#    """prints words of love"""    # description of sub-command
.#    user = kwargs.get('u', "you")
.#      # or raise CommandOptionError("sweet: required '-u username' option.")
.#    echo("I love %s!" % user)
.#.--------------------

.? result
.====================
### Don't forget to make script executable!
sh> chmod a+w appsvr

### Show help
sh> ./appsvr {{*-h*}}
appsvr - start/stop web application server

sub-commands:
  start           : start server process
  stop            : stop server process

(Type 'appsvr -h subcommand' to show options of sub-commands.)

### Show help for each sub-command
sh> ./appsvr {{*-h start*}}
appsvr start - start server process
  -p port              : port number
  -d                   : debug

### Invoke sub-command
sh> ./appsvr {{*start -p 4223*}}
appending output to nohup.out
sh> ./appsvr {{*stop*}}
.====================


.#.? 'mygit' script
.#.-------------------- mygit
.#{{*#!/usr/bin/env pykook -X*}}
.#
.#from kook.utils import CommandOptionError
.#
.#{{*kook_desc =*}} "example script to show pyKook's CLI framework feature"
.#
.#@recipe
.#def st(c):
.#    """invokes git status"""      # description of sub-command
.#    system_f("git status | egrep -v '^# *('")
.#
.#@recipe
.#def revert(c, *args):
.#    """invokes git checkout"""    # description of sub-command
.#    system("git checkout " + ' '.join(args))
.#
.#@recipe
.#@spices("-m message: commit message for 'git commit'")
.#def ci(c, *args, **kwargs):
.#    """invokes git commit"""      # description of sub-command
.#    cmd = "git commit "
.#    if 'm' in kwargs: cmd += "-m %s " % repr(kwargs['m'])
.#    cmd += args and ' '.join(args) or '-a'
.#    system(cmd)
.#.--------------------
.#
.#.? result
.#.====================
.#### Don't forget to make script executable!
.#sh> chmod a+w mygit
.#
.#### Show help
.#sh> ./mygit {{*-h*}}
.#mygit - example script to show pyKook's CLI framework feature
.#
.#sub-commands:
.#  st              : invokes git status
.#  revert          : invokes git checkout
.#  ci              : invokes git commit
.#
.#(Type 'mygit -h subcommand' to show options of sub-commands.)
.#
.#### Show help for each sub-command
.#sh> ./mygit {{*-h ci*}}
.#mygit ci - invokes git commit
.#  -m message           : commit message for 'git commit'
.#
.#### Invoke sub-command
.#sh> ./mygit {{*ci -m "tweak files"*}}
.#[master (root-commit) ff4a6f5] Add all files
.# 3 files changed, 20 insertions(+), 0 deletions(-)
.#sh> vi README.txt
.#sh> ./mygit {{*st*}}
.## On branch master
.## Changed but not updated:
.##
.##       modified:   README.txt
.##
.#no changes added to commit (use "git add" and/or "git commit -a")
.#sh> ./mygit {{*revert README.txt*}}
.#sh> ./mygit {{*st*}}
.## On branch master
.#nothing to commit (working directory clean)
.#.====================


.$$ Short command                      | topic-short-command

[%= PROJECT %] provides {{,kk,}} command which is the same as {{,[%= COMMAND %],}} command, because {{,[%= COMMAND %],}} is too long to type many times :)

.====================
sh> kk all    # this is more confortable to type than [%= COMMAND %] :)
.====================

In fact, {{,kk,}} is a shell script to invoke {{,pykook,}} or {{,plkook,}} command according to filename of cookbook.
For example, {{,pykook,}} will be invoked by {{,kk,}} when {{,Kookbook.py,}} exists, or {{,plkook,}} will be invoked when {{,Kookbook.pl,}} exists.
Therefore {{*{{,kk,}} script requires {{,[%= BOOKNAME %],}} to invoke {{,[%= COMMAND %],}} command*}}.

.====================
### you can't invoke kk when [%= BOOKNAME %] doesn't exist
sh> ls [%= BOOKNAME %]
ls: [%= BOOKNAME %]: No such file or directory
sh> kk -h
kk: No kookbook found.
.====================

If you set {{,$KK_CLIMB,}} environment variable to {{,1,}}, {{,kk,}} script searches kookbook in the parent directory.

.====================
sh> ls -F
[%= BOOKNAME %]    src/    test/
sh> cd src/foo/bar/
sh> kk clean                       # ERROR
kk: No kookbook found.
sh> {{*export KK_CLIMB=1*}}
sh> kk clean                       # OK
### * clean (recipe=clean)
$ rm **/*.pyc
.====================


% if PYTHON     #####

.$$ Short notation                             | topic-short-notation

pyKook provides short notation of recipe.

.--------------------
### normal notation                   ### short notation
@recipe                               {{*@recipe('*.o', ['$(1).c', '$(1).h'])*}}
@product('*.o')                       def file_o(c):
@ingreds('$(1).c', '$(1).h')             system(c%"gcc -o $(ingred)")
def file_o(c):
   system(c%"gcc -c $(ingred)")

@recipe                               {{*@recipe('build', ['hello.o'])*}}
@ingreds('hello.o')                   def {{*task_*}}build(c):
def build(c):                            system(c%"gcc -o hello *.o")
   system(c%"gcc -o hello *.o")
.--------------------

{{,@recipe(),}} decorator can take two arguments.
.* 1st argument represents product. If you pass {{,None,}}, it will be ignored.
.* 2nd argument represents ingredients and should be list or tuple of string.
   And 2nd argument is optional.

% end    ##### if PYTHON


.$$ Debug mode				| topic-debug-mode

Command-line option {{,-D,}} or {{,-D2,}} turn on debug mode and debug message will be displayed.
{{,-D2,}} is higher debug level than {{,-D,}}.

.? example of {{,-D,}}
.====================
sh> [%= COMMAND %] -D hello 
*** debug: + begin hello
*** debug: ++ begin hello.o
*** debug: +++ material hello.c
*** debug: +++ material hello.h
*** debug: ++ create hello.o (recipe=file_hello_o)
### ** hello.o (recipe=file_hello_o)
$ gcc -g -c hello.c
*** debug: ++ end hello.o (content changed)
*** debug: + create hello (recipe=file_hello)
### * hello (recipe=file_hello)
$ gcc -g -o hello hello.o
*** debug: + end hello (content changed)
.====================



.$$ Invoke Recipes Forcedly		| topic-forcedly

Command-line option '-F' invokes recipes forcedly.
In the other words, timestamp of files are ignored when '-F' is specified.



.$$ Nested Array			| topic-nestedarray

You can specify not only filenames but also list of filenames as ingredient {{,@ingreds(),}}.
[%= PROJECT %] flatten arguments of {{,@ingreds(),}} automatically.

.? [%= BOOKNAME %]: specify list of filenames
.-------------------- [%= BASENAME %]13.[%= SUFFIX %]
from glob import glob
sources = glob("*.c")
objects = [ s.replace(".c", ".o") for s in sources ]

@recipe
@product("hello")
@ingreds({{*objects*}})    # specify list of filenams
def file_hello(c):
    system(c%"gcc -o $(product) $({{*ingreds*}})")  # expanded to filenames

@recipe
@product("*.o")
@ingreds("$(1).c")
def file_ext_o(c):
    sysytem(c%"gcc -c $(ingred)")
.--------------------

.#
.#.$$ Invoke rook command recursively	| topic-recursive
.#
.#There are two ways to invoke [%= COMMAND %] command recirsively.
.#
.#
.#.$$$ Automatic recursive invocation	| topic-recursive1
.#
.#Command-line option '-R' finds cookbooks under the current directly recirsively
.#and invokes [%= COMMAND %] command for each cookbooks.
.#
.#For example, assume that the following cookbooks exist and they have each ':clean' recipe.
.#.* project/[%= BOOKNAME %]
.#.* project/src/[%= BOOKNAME %]
.#.* project/doc/[%= BOOKNAME %]
.#
.#.#+++
.#.-------------------- project/[%= BOOKNAME %]
.#recipes:
.#  - product:	:clean
.#    method*: |
.#% if PHP
.#	k_remove('*.tar.gz', '*.gem');
.#% elsif RUBY
.#	rm_rf '*.tar.gz', '*.gem'
.#% elsif PYTHON
.#% else error() end
.#.--------------------
.#.-------------------- project/src/[%= BOOKNAME %]
.#recipes:
.#  - product:	:clean
.#    method*: |
.#% if PHP
.#	k_remove('*.o');
.#% elsif RUBY
.#	rm_f '*.o'
.#% elsif PYTHON
.#% else error() end
.#.--------------------
.#.-------------------- project/doc/[%= BOOKNAME %]
.#recipes:
.#  - product:	:clean
.#    method*: |
.#% if PHP
.#	k_remove('*.html');
.#% elsif RUBY
.#	rm_rf '*.html'
.#% elsif PYTHON
.#% else error() end
.#.--------------------
.#.#---
.#
.#If you invoke [%= COMMAND %] command with '-R' option at 'project/' directory,
.#all cookbooks are detected automatically and [%= COMMAND %] command is invoked for each cookbooks.
.#
.#.? command-line example
.#.==================== [%= BASENAME %]20.recursive1.result
.#sh> [%= COMMAND %] {{*-R*}} :clean
.#.#@.<<<:! (cd project; [%= COMMAND %] -R :clean)
.#.#.<<<:! (cd project; [%= COMMAND %] -R :clean | sed 's!^\$ \/.*\/rook!$ /usr/local/bin/rook!' )
.#% if PHP
.#...
.#% elsif RUBY
.#
.#$ chdir .
.#$ /usr/local/bin/rook -R :clean
.#### * :clean
.#rook$ rm -rf *.tar.gz *.gem
.#
.#$ chdir doc
.#$ /usr/local/bin/rook -R :clean
.#### * :clean
.#rook$ rm -rf *.html
.#
.#$ chdir src
.#$ /usr/local/bin/rook -R :clean
.#### * :clean
.#rook$ rm -f *.o
.#% elsif PYTHON
.#% else error() end
.#.====================
.#
.#Some cookbooks have no target recipe. In this case, [%= COMMAND %] command reports warning message but never abort as error.
.#
.#% if PHP
.#.#Turn of cookbooks is not defined{{(Turn of cookbooks depends on {{,kook_glob('**/[%= BASENAME %].{yaml,yml,php}'),}})}}.
.#% elsif RUBY
.#.#Turn of cookbooks is not defined{{(Turn of cookbooks depends on {{,Dir.glob('**/[%= BASENAME %].{yaml,yml,rb}'),}})}}.
.#% elsif PYTHON
.#% else error() end
.#
.#
.#.$$$ Explicitly invocation in recipes	| topic-recursive2
.#
.#% if PHP
.#Using helper functions {{,kook_options(),}} and {{,kook_command(),}},
.#it is able to invoke [%= COMMAND %] command recursively in your recipe.
.#{{,kook_options(),}} returns [%= COMMAND %]'s command-line options,
.#and {{,kook_command(),}} returns [%= COMMAND %]'s command-name and options.
.#In fact, {{,kook_command(),}} is equivarent to {{,"#{$0} #{kook_options()}",}}.
.#Notice that these helper functions doesn't include target product names.
.#% elsif RUBY
.#Using helper functions {{,rook_options(),}} and {{,rook_command(),}},
.#it is able to invoke [%= COMMAND %] command recursively in your recipe.
.#{{,rook_options(),}} returns [%= COMMAND %]'s command-line options,
.#and {{,rook_command(),}} returns [%= COMMAND %]'s command-name and options.
.#In fact, {{,rook_command(),}} is equivarent to {{,"#{$0} #{rook_options()}",}}.
.#Notice that these helper functions doesn't include target product names.
.#% elsif PYTHON
.#% else error() end
.#
.#Following is an example of invocation of [%= COMMAND %] command in recipes.
.#
.#.? [%= BOOKNAME %]: example of rook_command()
.#.-------------------- project/[%= BASENAME %]21.yaml
.#recipes:
.#  - product:	:clean
.#    method*: |
.#% if PHP
.#  	k_remove('*.tgz', '*.tmp');
.#        $currdir = getcwd();
.#	foreach (array('src', 'doc') as $dir) {
.#	    k_chdir($dir);
.#	    sys(kook_command() . " :clean");
.#	    k_backdir($currdir);
.#	}
.#% elsif RUBY
.#  	rm_f '*.tar.gz', '*.gem'
.#        for dir in ['src', 'doc']
.#	  chdir dir do
.#	    {{*sys "#{rook_command()} :clean"*}}    # invoke recursively
.#	  end
.#	end
.#% elsif PYTHON
.#% else error() end
.#.--------------------
.#
.#.? command-line example
.#.==================== [%= BASENAME %]21.recursive2.result
.#sh> [%= COMMAND %] -F :clean
.#% if PHP
.#...
.#% elsif RUBY
.#### * :clean
.#rook$ rm -f *.tar.gz *.gem
.#rook$ chdir src
.#rook$ /usr/local/bin/rook  -F :clean
.####### (enter nested rook: PWD=/tmp/project/src)
.####### * :clean
.#rook$ rm -f *.o
.####### (exit nested rook)
.#rook$ chdir -   # /tmp/project
.#rook$ chdir doc
.#rook$ /usr/local/bin/rook  -F :clean
.####### (enter nested rook: PWD=/tmp/project/doc)
.####### * :clean
.#rook$ rm -rf *.html
.####### (exit nested rook)
.#rook$ chdir -   # /tmp/project
.#% elsif PYTHON
.#% else error() end
.#.====================
.#
.#{{,[%= PROJECT %]_options(),}} (and {{,[%= PROJECT %]_command(),}}) returns
.#{{,-D,}}(debug), {{,-F,}}(forcedly), {{,-N,}}(never execute), {{,-n,}}(no execute), {{,-q,}}(quiet), {{,-Q,}}(more quiet), {{,-T,}}(don't expand tabs), {{,-V,}}(verbosely), {{,-k,}}(kanji), and {{,--{{/name/}}={{/value/}},}}(properties).
.#Other command-line options (and target products) are not returned because they are not necessary to invoke [%= COMMAND %] recursively.
.#
.#


.$ Trouble Shooting		| trouble


.$$ xxx: product not created (in file_xxx())	| trouble-product-not-created

Q: I got the "xxx: product not created (in file_xxx())." error.

.#A: Define task recipe instead of file recipe. In other words, define 'task_xxx()' instead of 'file_xxx()'.
.A: You may define file recipe instead of task recipe. Don't specify '@product()' if you want to define task recipe.

    .--------------------
    ## This will cause error
    @recipe
    @product("clean")
    def clean(c):   #=> KookRecipeError: clean: product not created (in file_clean()).
        rm_f("*.o")

    ## Don't specify @product()
    @recipe
    def clean(c):   #=> ok
        rm_f("*.o")

    ## Or add 'task_' prefix to function name
    @recipe
    @product("clean")
    def {{*task_*}}clean(c):        #=> almost equivarent to above recipe
        rm_f("*.o")
    .--------------------


.$$ *.c: can't find any recipe to produce.	| trouble-cant-find-any-recipe-to-produce

Q: I got the "*.c: can't find any recipe to produce." error.

A: Use "$(1).c" instead of "*.c" in @ingreds() argument.

    .--------------------
    ## This will cause error because "*.c" is used in ingredients.
    @recipe
    @product("*.o")
    @ingreds("*.c")  #=> KookRecipeError: *.c: can't find any recipe to produce.
    def file_ext_o(c):
        system(c%"gcc -c $(ingred)")

    ## Use "$(1).c" instead of "*.c"
    @recipe
    @product("*.o")
    @ingreds("{{*$(1)*}}.c")  #=> ok
    def file_ext_o(c):
        system(c%"gcc -c $(ingred)")
    .--------------------


.$$ sh: line 1: ingred: command not found	| trouble-ingred-command-not-found

Q: I got the "sh: line 1: ingred: command not found" error.

A: Add "c%" at the beginning of command string.

    .--------------------
    ## "c%" is forgetten
    @recipe
    @product("*.o")
    @ingreds("$(1).c")
    def file_ext_o(c):
        system("gcc -c $(ingred)")
	    #=> KookCommandError: sh: line 1: ingred: command not found" error.

    ## Don't forget to add "c%" if you want to use "$()".
    @recipe
    @product("*.o")
    @ingreds("$(1).c")
    def file_ext_o(c):
        system({{*c%*}}"gcc -c $(ingred)")
    .--------------------




.$ References				| refs


.$$ Filesystem Functions			| refs-filesystem

The following functions are available in recipe.

.[ system({{/cmmand-string/}}) ]
	Execute {{/command-string/}}. If command status is not zero then exception is raised.
	.--------------------
	system("gcc hello.c")
	.--------------------

.[ system_f({{/command-string/}}) ]
	Execute {{/command-string/}}. Command statuis is ignored.

.[ echo({{/string/}}) ]
	Echo {{/string/}}. Newline is printed.
	.--------------------
	echo("OK.")
	.--------------------

.[ echo_n({{/string/}}) ]
	Echo {{/string/}}. Newline is not printed.
	.--------------------
	echo_n("Enter your name: ")
	.--------------------

.[ cd({{/dir/}}) ]
	Change directory. Return current directory.
	.--------------------
	cwd = cd("build")
	...
	cd(cwd)              # back to current directry
	.--------------------

.[ chdir({{/dir/}}) ]
	Change current directory temporary. If this is used with Python's with-statement, current directory will be backed automatically.
	.--------------------
	with chdir("build") as d:
	   ...     # into "build" directory
	# back to current directry automatically
	.--------------------

.#.[ chmod({{/mode/}}, {{/path/}}[, {{/path2/}}, ...]) ]
.#	Change permission of {{/path/}}.
.#	.--------------------
.#	chmod(0644, "lib/**/*.rb")
.#	chmod(0755, "bin/*")
.#	.--------------------
.#
.#.[ chmod_R({{/mode/}}, {{/path/}}[, {{/path2/}}, ...]) ]
.#	Change permission of {{/path/}} recursively.
.#	.--------------------
.#	chmod_R(0644, "lib")
.#	.--------------------
.#
.#.[ chown({{/user/}}, {{/group/}}, {{/path/}}[, {{/path2/}}, ...]) ]
.#	Change owner of {{/path/}}. If {{/user/}} or {{/group/}} is nil then no changed.
.#	.--------------------
.#	chown('nobody', None, "lib/**/*.rb")
.#	.--------------------
.#
.#.[ chown_R({{/owner/}}, {{/group/}}, {{/path/}}[, {{/path2/}}, ...]) ]
.#	Change owner of {{/path/}} recursively. If {{/user/}} or {{/group/}} is nil then no changed.
.#	.--------------------
.#	chown('nobody', None, "lib")
.#	.--------------------

.[ mkdir({{/path/}}) ]
	Make directory.
	.--------------------
	mkdir("lib")
	.--------------------

.[ mkdir_p({{/path/}}) ]
	Make directory. If parent directory is not exist then it is created automatically.
	.--------------------
	mkdir_p("foo/bar/baz")
	.--------------------

.[ rm({{/path/}}[, {{/path2/}}, ...]) ]
	Remove files.
	.--------------------
	rm('*.html', '*.txt')
	.--------------------

.[ rm_r({{/path/}}[, {{/path2/}}, ...]) ]
	Remove files or directories recursively.
	.--------------------
	rm_r('*')
	.--------------------

.[ rm_f({{/path/}}[, {{/path2/}}, ...]) ]
	Remove files forcedly. No errors reported even if {{/path/}} doesn't exist.
	.--------------------
	rm_f('*.html', '*.txt')
	.--------------------

.[ rm_rf({{/path/}}[, {{/path2/}}, ...]) ]
	Remove files or directories forcedly.
	No errors reported even if {{/path/}} doesn't exist.
	.--------------------
	rm_rf('*')
	.--------------------

.[ touch({{/path/}}[, {{/path2/}}, ...]) ]
	Touch files or directories. If {{/path/}} doesn't exist then empty file is created.
	.--------------------
	touch('*.c')
	.--------------------

.[ cp({{/file1/}}, {{/file2/}}) ]
	Copy {{/file1/}} to {{/file2/}}.
	.--------------------
	cp('foo.txt', 'bar.txt')
	.--------------------

.[ cp({{/file/}}, {{/file2/}}, ..., {{/dir/}}) ]
	Copy {{/file/}} to {{/dir/}}.
	.--------------------
	cp('*.txt', '*.html', 'dir')
	.--------------------

.[ cp_r({{/path1/}}, {{/path2/}}) ]
	Copy {{/path1/}} to {{/path2/}} recursively.
	.--------------------
	cp_r('dir1', 'dir2')
	.--------------------

.[ cp_r({{/path/}}, {{/path2/}}, ..., {{/dir/}}) ]
	Copy {{/path/}} to {{/dir/}} recursively.  Directory {{/dir/}} must exist.
	.--------------------
	cp_r('lib', 'doc', 'test', 'dir')
	.--------------------

.[ cp_p({{/file1/}}, {{/file2/}}) ]
	Copy {{/file1/}} to {{/file2/}}. Timestams is preserved.
	.--------------------
	cp_p('foo.txt', 'bar.txt')
	.--------------------

.[ cp_p({{/file/}}, {{/file2/}}, ..., {{/dir/}}) ]
	Copy {{/file/}} to {{/dir/}}. Timestams is preserved.   Directory {{/dir/}} must exist.
	.--------------------
	cp_p('*.txt', '*.html', 'dir')
	.--------------------

.[ cp_pr({{/path1/}}, {{/path2/}}) ]
	Copy {{/path1/}} to {{/path2/}} recursively.  Timestams is preserved.
	.--------------------
	cp_pr('lib', 'lib.bkup')
	.--------------------

.[ cp_pr({{/path/}}, {{/path2/}}, ..., {{/dir/}}) ]
	Copy {{/path/}} to {{/dir/}} recursively. Directory {{/dir/}} must exist. Timestams is preserved.
	.--------------------
	cp_pr('lib/**/*.rb', 'test/**/*.rb', 'tmpdir')
	.--------------------

.#.[ cp_a {{/path/}}, {{/path2/}}, ..., {{/dir/}} ]
.#	Copy {{/path/}} to {{/dir/}} recursively.  Timestams is preserved.

.[ mv({{/file1/}}, {{/file2/}}) ]
	Rename {{/file1/}} to {{/file2/}}.
	.--------------------
	mv('foo.txt', 'bar.txt')
	.--------------------

.[ mv({{/path/}}, {{/path2/}}, ..., {{/dir/}}) ]
	Move {{/path/}} to {{/dir/}}.
	.--------------------
	mv('lib/*.rb', 'test/*.rb', 'tmpdir')
	.--------------------

.#.[ ln({{/file1/}}, {{/file2/}}) ]
.#	Create hard-link.
.#	.--------------------
.#	ln('file1.txt', 'file2.txt')
.#	.--------------------
.#
.#.[ ln_s({{/path/}}, {{/path2/}}) ]
.#	Create symblic-link.
.#	.--------------------
.#	ln_s('dir1', 'dir2')
.#	ln_s('*.txt', 'dir')
.#	.--------------------
.#
.#.[ ln_sf({{/path/}}, {{/path2/}}) ]
.#	Create symblic-link forcedly.
.#	.--------------------
.#	ln_sf('dir1', 'dir2')
.#	ln_sf('*.txt', 'dir')
.#	.--------------------

.[ store({{/path/}}, {{/path2/}}, ..., {{/dir/}}) ]
	Copy {{/path/}} (files or directories) to {{/dir/}} with keeping path-structure.
	.--------------------
	store("lib/**/*.py", "doc/**/*.{html,css}", "dir")
	## ex.
	##   "lib/kook/__init__.py"  is copied into "dir/lib/kook/__init__.py"
	##   "lib/kook/utils.py"     is copied into "dir/lib/kook/utils.py"
	##   "lib/kook/main.py"      is copied into "dir/lib/kook/main.py"
	##   "doc/users-guide.html"  is copied into "dir/doc/users-guide.html"
	##   "doc/docstyle.css"      is copied into "dir/doc/docstyle.css"
	.--------------------

.[ store_p({{/path/}}, {{/path2/}}, ..., {{/dir/}}) ]
	Copy {{/path/}} (files or directories) to {{/dir/}} with keeping path-structure.
	Timestamp is preserved.
	.--------------------
	store_p("lib/**/*.py", "doc/**/*.html", "dir")
	.--------------------

.#.[ store_a({{/path/}}, {{/path2/}}, ..., {{/dir/}}) ]
.#	Copy {{/path/}} (files or directories) to {{/dir/}} with keeping path-structure.
.#	Timestamp is preserved.
.#	.--------------------
.#	store_a("lib/**/*.rb", "doc/**/*.html", "dir")
.#	.--------------------

.[ edit({{/path/}}, {{/path2/}}, ..., by=replacer) ]
	Edit file content.
	Keyword argument 'by' should be a callable to edit content, or list of tuples of replacing pattern and string.
	.#If {{/path/}} is directory then it is ignored.
	.--------------------
	## edit by list of regular expression and string
	replacer = [
	    (r'\$Release\$', "1.0.0"),
	    (r'\$Copyright\$', "copyright(c) 2008 kuwata-lab.com"),
	]
	edit("lib/**/*.py", "doc/**/*.{html,css}", by=replacer)
	## edit by function
	def replacer(s):
	    s = s.replace('${{}}Release$',   "1.0.0", s)
	    s = s.replace('${{}}Copyright$', "copyright(c) 2008 kuwata-lab.com", s)
	    return s
	edit("lib/**/*.py", "doc/**/*.{html,css}", by=replacer)
	.--------------------

.#.[ zip({{/archive/}}, {{/path1/}}, {{/path2/}}, ...) ]
.#	Create zip archive file. Requires {{<rubyzip|http://raa.ruby-lang.org/project/rubyzip/>}} library.
.#	.--------------------
.#	zip('file.zip', 'file1.txt', 'file2.txt')
.#	.--------------------
.#
.#.[ zip_r({{/archive/}}, {{/path1/}}, {{/path2/}}, ...) ]
.#	Create zip archive file recursively. Requires {{<rubyzip|http://raa.ruby-lang.org/project/rubyzip/>}} library.
.#	.--------------------
.#	zip_r('file.zip', 'lib', 'doc', 'test')
.#	.--------------------
.#
.#.[ unzip({{/archive/}}) ]
.#	Unzip archive file. Requires {{<rubyzip|http://raa.ruby-lang.org/project/rubyzip/>}} library.
.#	.--------------------
.#	unzip('file.zip')
.#	.--------------------
.#
.#.[ tar_cf({{/archive/}}, {{/path1/}}, {{/path2/}}, ...) ]
.#	Create tar archive. Requies {{<minitar|http://raa.ruby-lang.org/project/minitar/>}} library.
.#	.--------------------
.#	tar_cf('file.tar', 'lib', 'doc', 'test')
.#	.--------------------
.#
.#.[ tar_xf({{/archive/}}) ]
.#	Extract tar archive. Requies {{<minitar|http://raa.ruby-lang.org/project/minitar/>}} library.
.#	.--------------------
.#	tar_xf('file.tar')
.#	.--------------------
.#
.#.[ tar_czf({{/archive/}}, {{/path1/}}, {{/path2/}}, ...) ]
.#	Create gzipped tar archive. Requies {{<minitar|http://raa.ruby-lang.org/project/minitar/>}} library.
.#	.--------------------
.#	tar_czf('file.tar.gz', 'lib', 'doc', 'test')
.#	.--------------------
.#
.#.[ tar_xzf({{/archive/}}) ]
.#	Extract gzipped tar archive. Requies {{<minitar|http://raa.ruby-lang.org/project/minitar/>}} library.
.#	.--------------------
.#	tar_xzf('file.tar.gz')
.#	.--------------------
.#
.#.[ tar_cjf({{/archive/}}, {{/path1/}}, {{/path2/}}, ...) ]
.#	Create gzipped tar archive.
.#	Requies {{<minitar|http://raa.ruby-lang.org/project/minitar/>}} library
.#	and {{<bz2|http://raa.ruby-lang.org/project/bz2/>}} library.
.#	.--------------------
.#	tar_cjf('file.tar.bz2', 'lib', 'doc', 'test')
.#	.--------------------
.#
.#.[ tar_xjf({{/archive/}}) ]
.#	Extract gzipped tar archive.
.#	Requies {{<minitar|http://raa.ruby-lang.org/project/minitar/>}} library
.#	and {{<bz2|http://raa.ruby-lang.org/project/bz2/>}} library.
.#	.--------------------
.#	tar_xjf('file.tar.bz2')
.#	.--------------------



The above functions can take lists or tuples as file or directory names.
(If argument is list or tuple, it is flatten by {{,kook.utils.flatten(),}}.)

For example, the following code is available.

.--------------------
## copy all files into dir
files = ['file1.txt', 'file2.txt', 'file3.txt']
cp(files, 'dir')
.--------------------

The following file pattern is available.
.[ {{,*,}} ]
	Matches sequence of any character.
.[ {{,?,}} ]
	Matches a character.
.[ {{,{{{/a/}},{{/b/}},{{/c/}}},}}
	Matches {{/a/}} or {{/b/}} or {{/c/}}.
.[ {{,**/,}} ]
	Matches directory recursively.


.#
.#.$$ Command-line options		| refs-cmdopts
.#
.#Usage: [%= command %] [..options..] [product [arguments...]]
.#
.#Options:
.#
.#.[ -h ]
.#	Print help and quit.
.#
.#.[ -v ]
.#	Print version and quit.
.#
.#.[ -l ]
.#	List properties and described recipes.
.#
.#.[ -L ]
.#	List all propeties, parameters, and recipes.
.#
.#.[ -q ]
.#	Quiet mode.
.#
.#.[ -Q ]
.#	More quiet mode.
.#
.#.[ -F ]
.#	Force recipes to execute (ignore timestamps).
.#
.#% if PHP
.#.[ -n ]
.#	No execution (print 'k_xxx()' command functions).
.#
.#.[ -N ]
.#	No execution (print 'method*:' part of recipes).
.#% elsif RUBY
.#.[ -n ]
.#	No command execution. Notice that ruby code is executed.
.#
.#% elsif PYTHON
.#% else error() end
.#
.#.[ -T ]
.#	Don't untabify cookbook.
.#	In default [%= PROJECT %] command expands tab characters in cookbook into spaces,
.#	because YAML parser doesn't allow cookbook (= YAML document) to include tab characters.
.#	Command-line option '-T' doesn't expand tab characters.
.#
.#.[ -c ]
.#	Validation check of cookbook.
.#
.#.[ -R ]
.#	Find cookbooks under the current directory and invoke [%= COMMAND %] command for each cookbooks.
.#
.#.[ -b {{/bookname/}}, -f {{/bookname/}} ]
.#	Cookbook filename.
.#
.#.[ -P {{/propfile/}} ]
.#	Property filename (default is 'Properties.[%= SUFFIX %]').
.#	'-P -' means not to read property file.
.#
.#.[ --{{/propname/}}={{/propvalue/}} ]
.#	Property name and value.
.#

.#@EOF

.$ Todo		  	   | todo

.* [_] Fingerprints
.* [_] Auto-detection of product and by-product, and delete them automatically
.* [_] Include external cookbook
.* [_] Multi-products
.* [V] {{=Reporting Line number when schema error is found in cookbook=}}
.* [_] Convertion cookbook into [%= LANG %] code



.-------------------- hello.c
#include <stdio.h>
#include "hello.h"

int main(int argc, char *argv[]) {
    extern char *message;
    printf("%s\n", message);
    return 0;
}
.--------------------

.-------------------- hello.h
char *message = "Hello world!";
.--------------------

.-------------------- package.xml
<?xml version="1.0"?>
.--------------------

.-------------------- README
README
.--------------------

.-------------------- ChangeLog
ChangeLog:
.--------------------

.-------------------- COPYING
copyright(c)
.--------------------

% if PHP
.-------------------- lib/foo.php
#!/usr/bin/env php
.--------------------
.-------------------- lib/bar.php
#!/usr/bin/env php
.--------------------
.-------------------- lib/baz.php
#!/usr/bin/env php
.--------------------
% elsif RUBY
.-------------------- lib/foo.rb
#!/usr/bin/env ruby
.--------------------
.-------------------- lib/bar.rb
#!/usr/bin/env ruby
.--------------------
.-------------------- lib/baz.rb
#!/usr/bin/env ruby
.--------------------
% elsif PYTHON
% else error() end
