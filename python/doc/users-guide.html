<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
  <meta name="generator" content="HTML Tidy for Mac OS X (vers 31 October 2006 - Apple Inc. build 13), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html">

  <title>pyKook Users' Guide</title>
  <meta name="generator" content="kwaser">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <link rel="stylesheet" href="docstyle.css" type="text/css">
</head>

<body>
  <blockquote>
    <div class="mainbody">
      <div align="left">
        <h1>pyKook Users' Guide</h1>
      </div>

      <div align="left">
        release: $Release$<br>
      </div><a name="preface" id="preface"></a>

      <h2 class="section1">Preface</h2>

      <p><a href="http://www.kuwata-lab.com/kook/">pyKook</a> is a software build tool such as Make, <a href="http://ant.apache.org/">Ant</a>, <a href="http://www.scons.org/">SCons</a> or <a href="http://www.canb.auug.org.au/~millerp/cook/cook.html">Cook</a>. It is implemented in Python and runs any platform Python support. Basic command (copy, move, rename, mkdir, ...) is also implemented in Python and allows you to execute platform-depended command.</p>

      <p>pyKook liken build process to cooking. Input file is called 'ingredient', output is 'product', task is 'recipe', build file is 'cookbook'. pyKook generates products from ingredients according to recipes. You describe products, ingredients, and recipes in cookbook.</p>

      <p>Features:</p>

      <ul type="disc">
        <li>Impremented in pure Rython and runs any platform which Python supports.</li>

        <li>Input file (called 'cookbook') is named 'Kookbook.py', which is equivarent to 'Makefile' of Make or 'build.xml' of Ant.</li>

        <li>Cookbook's format is pure Python. You can write any Python code in kookbook.</li>
      </ul>

      <p><span style="color:#FF0000">Caution! pyKook is currently under experimental. It means that the design and specification of pyKook may change frequently.</span></p><a name="toc" id="toc"></a>

      <h3 class="section2">Table of Contents</h3>

      <ul>
        <li>
          <a href="#preface">Preface</a>

          <ul>
            <li><a href="#toc">Table of Contents</a></li>
          </ul>
        </li>

        <li>
          <a href="#cookbook">Cookbook</a>

          <ul>
            <li><a href="#cookbook-recipes">Recipes</a></li>

            <li><a href="#cookbook-prod">Product and Ingredients</a></li>

            <li><a href="#cook-grecipe">Specific recipe and generic recipe</a></li>

            <li><a href="#cookbook-if-exists">Conditional Ingredients</a></li>

            <li><a href="#cookbook-recipekind">File Recipes and Task Recipes</a></li>

            <li><a href="#cookbook-default-product">Default Product</a></li>

            <li><a href="#cookbook-props">Properties</a></li>

            <li><a href="#cookbook-materials">Materials</a></li>

            <li><a href="#cookbook-spices">Command-line options for recipe</a></li>
          </ul>
        </li>

        <li>
          <a href="#topic">Other features</a>

          <ul>
            <li><a href="#topc-debug-mode">Debug mode</a></li>

            <li><a href="#topic-short-command">Short command</a></li>

            <li><a href="#topic-forcedly">Invoke Recipes Forcedly</a></li>

            <li><a href="#topic-nestedarray">Nested Array</a></li>
          </ul>
        </li>

        <li>
          <a href="#trouble">Trouble Shooting</a>

          <ul>
            <li><a href="#trouble-product-not-created">xxx: product not created (in file_xxx())</a></li>

            <li><a href="#trouble-cant-find-any-recipe-to-produce">*.c: can't find any recipe to produce.</a></li>

            <li><a href="#trouble-ingred-command-not-found">sh: line 1: ingred: command not found</a></li>
          </ul>
        </li>

        <li>
          <a href="#refs">References</a>

          <ul>
            <li><a href="#refs-filesystem">Filesystem Functions</a></li>
          </ul>
        </li>
      </ul><br>
      <br>
      <a name="cookbook" id="cookbook"></a>

      <h2 class="section1">Cookbook</h2>

      <p>This sectipn describes how to write cookbook.</p><a name="cookbook-recipes" id="cookbook-recipes"></a>

      <h3 class="section2">Recipes</h3>

      <p>Cookbook should contains some recipes. Each recipes are described with function and function decorators.</p>

      <ul type="disc">
        <li><code>@product()</code> decorator represents filename which is generated by the recipe. This takes only an argument.</li>

        <li><code>@ingreds()</code> decorator represents filenames which are required to generate product. This can take several arguments.</li>

        <li>function <code>file_xxx()</code> represents how to generate the product from ingredients. It is called as recipe function. Name of recipe function should be <code>file_xxx()</code> or <code>task_xxx()</code> and it should take an argument.</li>

        <li>function description is regarded as recipe description.</li>
      </ul>

      <p>In cookbook, some helper functions provided by pyKook are available. For exaple, function '<code>system()</code>' invokes OS-depend command. See <a href="#refs">References</a> for details about helper functions.</p>

      <p>The following is an example of recipe definitions in cookbook.</p><a name="Kookbook1.py" id="Kookbook1.py"></a>

      <div class="program_caption">
        Kookbook.py: Compile hello.c so that to generate 'hello' command.
      </div>
      <pre class="program">
# product "hello" depends on "hello.o".
@product("hello")
@ingreds("hello.o")
def file_hello(c):
    """generates hello command"""           # recipe description
    system("gcc -g -o hello hello.o")

# product "hello.o" depends on "hello.c" and "hello.h".
@product("hello.o")
@ingreds("hello.c", "hello.h")
def file_hello_o(c):
    """compile 'hello.c' and 'hello.h'"""   # recipe description
    system("gcc -g -c hello.c")
</pre>

      <p>The following is an example of invoking <code>pykook</code> command<sup>(<a href="#fnref:1" name="fnlink:1" id="fnlink:1">*1</a>)</sup>. Command-line option '<code>-l</code>' shows recipes which have description. It means that recipes which have description are public recipes. Command-line option '<code>-L</code>' shows all recipes.</p><a name="Kookbook1.recipe.result" id="Kookbook1.recipe.result"></a>

      <div class="terminal_caption">
        command-line example
      </div>
      <pre class="terminal">
sh&gt; pykook -l
Properties:

Task recipes:

File recipes:
  hello               : generates hello command
  hello.o             : compile 'hello.c' and 'hello.h'

(Tips: you can set 'kook_default_product' variable in your kookbook.)

sh&gt; pykook hello
### ** hello.o (func=file_hello_o)
$ gcc -g -c hello.c
### * hello (func=file_hello)
$ gcc -g -o hello hello.o
</pre>

      <p>pyKook checks both timestamps and contents of files (= products, ingredients).</p>

      <ul type="disc">
        <li>If product is older than ingredients, that recipe will be executed.</li>

        <li>If product is newer than or have the same timestamp as ingredients, that recipe will not be executed.</li>

        <li>If recipe of ingredient is executed but content of ingredient is not changed, then recipe of product will not be executed and product will be 'touched'.</li>

        <li>If you specify command-line option '<code>-F</code>', these rules are ignored and all recipes are executed forcedly.</li>
      </ul><a name="Kookbook1.product2.result" id="Kookbook1.product2.result"></a>
      <pre class="terminal">
sh&gt; pykook hello               # 1st time
### ** hello.o (func=file_hello_o)
$ gcc -g -c hello.c
### * hello (func=file_hello)
$ gcc -g -o hello hello.o

sh&gt; pykook hello               # 2nd time
                               # nothing, because hello is already created.

sh&gt; touch hello.c              # touch hello.c
sh&gt; pykook hello               # 3rd time
### ** hello.o (func=file_hello_o)
$ gcc -g -c hello.c            # compiled, because hello.c is newer than hello.o.
### * hello (func=file_hello)
$ <strong>touch hello   # skipped</strong>      # skipped, because content of hello.o is not changed.

sh&gt; pykook <strong>-F</strong> hello            # 4th time (forcedly)
### ** hello.o (func=file_hello_o)
$ gcc -g -c hello.c
### * hello (func=file_hello)
$ gcc -g -o hello hello.o
</pre>

      <div class="footnote">
        <dl compact>
          <dt>(<a name="fnref:1" href="#fnlink:1" id="fnref:1">*1</a>)</dt>

          <dd>pyKook also provides <code>kk</code> command which is equivarent to <code>pykook</code>, because <code>pykook</code> is too long to type many times :)</dd>
        </dl>
      </div><br>
      <a name="cookbook-prod" id="cookbook-prod"></a>

      <h3 class="section2">Product and Ingredients</h3>

      <p>Product and ingredient names are referable as property of recipe function's argument.</p>

      <ul type="disc">
        <li>Property 'c.product' represents product.</li>

        <li>Property 'c.ingreds' represents ingredients.</li>

        <li>Property 'c.ingred' represents the first item of ingredients (= c.ingreds[0]).</li>
      </ul><a name="Kookbook.py2.py" id="Kookbook.py2.py"></a>

      <div class="program_caption">
        Kookbook.py: Use <code>c.product</code> and <code>c.ingreds</code>
      </div>
      <pre class="program">
# product "hello" depends on "hello.o".
@product("hello")
@ingreds("hello.o")
def file_hello(c):
    """generates hello command"""
    system("gcc -g -o %s %s" % (<strong>c.product</strong>, <strong>c.ingred</strong>))
    # or system("gcc -g -o %s %s" % (<strong>c.product</strong>, <strong>c.ingreds[0]</strong>))
    # or system(<strong>c%</strong>"gcc -g -o <strong>$(product)</strong> <strong>$(ingreds[0])</strong>")

# product "hello.o" depends on "hello.c" and "hello.h".
@product("hello.o")
@ingreds("hello.c", "hello.h")
def file_hello_o(c):
    """compile 'hello.c' and 'hello.h'"""
    system("gcc -g -c %s" % <strong>c.ingred</strong>)
    # or system("gcc -g -c %s" % <strong>c.ingreds[0]</strong>)
    # or system(<strong>c%</strong>"gcc -g -c <strong>$(ingred)</strong>")
</pre><a name="Kookbook2.product.result" id="Kookbook2.product.result"></a>

      <div class="terminal_caption">
        command-line example
      </div>
      <pre class="terminal">
sh&gt; pykook hello
### ** hello.o (func=file_hello_o)
$ gcc -g -c hello.c
### * hello (func=file_hello)
$ gcc -g -o hello hello.o
</pre>

      <p>pyKook provides convenience way to embed variables into string literal. For example, the followings are equivarent.</p>
      <pre class="program">
system("gcc -g -o %s %s" % (c.product, c.ingreds[0]))
system(c%"gcc -g -o $(product) $(ingreds[0])")
</pre>

      <p>You can write local or global variables in <code>$()</code> as well as <code>product</code> or <code>ingreds</code>.</p>
      <pre class="program">
CC     = 'gcc'             # global variable

@product("hello")
@ingreds("hello.o")
def file_hello(c):
    CFLAGS = '-g -Wall'    # local variable
    system(c%"<strong>$(CC)</strong> <strong>$(CFLAGS)</strong> -o $(product) $(ingreds[0])")
</pre><br>
      <a name="cook-grecipe" id="cook-grecipe"></a>

      <h3 class="section2">Specific recipe and generic recipe</h3>

      <p>Specific recipe is a recipe which is combined to a certain file. Product name of specific recipe is a concrete file name.</p>

      <p>Generic recipe is a recipe which is combined to a pattern of file name. Product name of generic recipe is a pattern with metacharacter or regular expression.</p>

      <p>pyKook converts file name pattern into regular expression. For example:</p>

      <ul type="disc">
        <li><code>'*.o'</code> will be coverted into <code>r'^(.*?)\.o$'</code>.</li>

        <li><code>'*.??.txt'</code> will be converted into to <code>r'^(.*?)\.(..)\.txt$'</code>.</li>
      </ul>

      <p>Matched strings with metacharacter ('*' or '?') are accessable by <code>$(1)</code>, <code>$(2)</code>, ... in <code>@ingreds()</code> decorator.</p><a name="Kookbook3.py" id="Kookbook3.py"></a>

      <div class="program_caption">
        Kookbook.py: Compile hello.c so that to generate 'hello' command.
      </div>
      <pre class="program">
## specific recipe
@product("hello")
@ingreds("hello.o")
def file_hello(c):
    """generates hello command"""
    system(c%"gcc -g -o $(product) $(ingred)")
    # or system("gcc -g -o %s %s" % (c.product, c.ingred))
    # or system("gcc -g -o %s %s" % (c.product, c.ingreds[0]))

## generic recipe
@product("<strong>*.o</strong>")        # or @product(re.compile(r'^(.*?)\.o$'))
@ingreds("<strong>$(1)</strong>.c", "<strong>$(1)</strong>.h")
def file_ext_o(c):
    """compile '*.c' and '*.h'"""
    system(c%"gcc -g -c <strong>$(1)</strong>.c")
    # or system("gcc -g -c %s.c" % <strong>c.m[1]</strong>)
    # or system("gcc -g -c %s" % c.ingred)
</pre><a name="Kookbook.py3.grecipe.result" id="Kookbook.py3.grecipe.result"></a>

      <div class="terminal_caption">
        command-line example
      </div>
      <pre class="terminal">
sh&gt; pykook -l
Properties:

Task recipes:

File recipes:
  hello               : generates hello command
  <strong>*.o</strong>                 : compile '*.c' and '*.h'

(Tips: you can set 'kook_default_product' variable in your kookbook.)

sh&gt; pykook hello
### ** hello.o (func=file_ext_o)
$ gcc -g -c hello.c
### * hello (func=file_hello)
$ gcc -g -o hello hello.o
</pre>

      <p>It is able to specify regular expression instead of filename pattern. For example, <code>re.compile(r'^(.*)\.o$')</code> is available as product instead of <code>*.o</code>. Grouping in regular expression is referable by <code>$(1)</code>, <code>$(2)</code>, ... in the same way.</p>

      <p>Specific recipe is prior to generic recipe. For example, recipe 'hello.o' is used and recipe '*.o' is not used to generate 'hello.o' when target product is 'hello.o' in the following example.</p>

      <div class="program_caption">
        Specific recipe is prior to generic recipe.
      </div>
      <pre class="program">
## When target is 'hello.o', this specific recipe will be used.
@product("hello.o")
@ingreds("hello.c")
def file_hello_o(c):
    system(c%"gcc -g -O2 -o $(product) $(ingred)")

## This generic recipe will not be used.
@product("*.o")
@ingreds("$(1).c", "$(1).h")
def file_o(c):
    system(c%"gcc -g     -o $(product) $(ingred)")
</pre><br>
      <a name="cookbook-if-exists" id="cookbook-if-exists"></a>

      <h3 class="section2">Conditional Ingredients</h3>

      <p>There may be a case that ingredient file exists or not. For example, product 'foo.o' depends on 'foo.c' and 'foo.h', while product 'bar.o' depends only on 'bar.c'.</p>

      <p>In this case, you can use <code>if_exists()</code> helper function which resolve the problem. For example, when <code>if_exists("hello.h")</code> is specified in <code>@ingreds()</code>, pyKook detect dependency as following.</p>

      <ul type="disc">
        <li>If file 'hello.h' exists, product 'hello.o' depends on ingredients 'hello.c' and 'hello.h'.</li>

        <li>If file 'hello.h' doesn't exist, product 'hello.o' depends on only 'hello.c'.</li>
      </ul>

      <p><code>if_exists()</code> is useful especially when used with generic recipes.</p><a name="Kookbook4.py" id="Kookbook4.py"></a>

      <div class="program_caption">
        Kookbook.py: Example of <code>if_exists()</code>
      </div>
      <pre class="program">
## specific recipe
@product("hello")
@ingreds("hello.o")
def file_hello(c):
    """generates hello command"""
    system(c%"gcc -g -o $(product) $(ingred)")
    # or system("gcc -g -o %s %s" % (c.product, c.ingred))
    # or system("gcc -g -o %s %s" % (c.product, c.ingreds[0]))

## generic recipe
@product("*.o")        # or @product(re.compile(r'^(.*?)\.o$'))
@ingreds("$(1).c", <strong>if_exists("$(1).h")</strong>)
def file_hello_o(c):
    """compile '*.c' and '*.h'"""
    system(c%"gcc -g -c $(1).c")
    # or system("gcc -g -c %s.c" % c.m[1])
    # or system("gcc -g -c %s" % c.ingred)
</pre><a name="Kookbook.py4.if_exists.result" id="Kookbook.py4.if_exists.result"></a>

      <div class="terminal_caption">
        command-line example
      </div>
      <pre class="terminal">
sh&gt; pykook hello
### ** hello.o (func=file_hello_o)
$ gcc -g -c hello.c
### * hello (func=file_hello)
$ gcc -g -o hello hello.o
</pre><br>
      <a name="cookbook-recipekind" id="cookbook-recipekind"></a>

      <h3 class="section2">File Recipes and Task Recipes</h3>

      <p>In pyKook, there are two kind of recipe.</p>

      <dl class="dl3">
        <dt class="dt3"><b>File recipe</b></dt>

        <dd class="dd3">File recipe is a recipe which generates a file. In the other word, product of recipe is a file. If product is not generated, the execution of recipe will be failed.</dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>Task recipe</b></dt>

        <dd class="dd3">Task recipe is a recipe which is not aimed to generate files. For example, task recipe 'clean' will remove '*.o' files and it doesn't generate any files.</dd>
      </dl>

      <p>Here is a matrix table of recipe kind.</p>

      <div align="center">
        <table class="table2" border="1" cellspacing="0">
          <tr class="tr2">
            <td class="td2"></td>

            <td class="td2"><strong>Specific recipe</strong></td>

            <td class="td2"><strong>Generic recipe</strong></td>
          </tr>

          <tr class="tr2">
            <td class="td2"><strong>File recipe</strong></td>

            <td class="td2">Specific file recipe</td>

            <td class="td2">Generic file recipe</td>
          </tr>

          <tr class="tr2">
            <td class="td2"><strong>Task recipe</strong></td>

            <td class="td2">Specific task recipe</td>

            <td class="td2">Generic task recipe</td>
          </tr>
        </table>
      </div>

      <p>Recipe function of file and task recipes should be started with 'file_' and 'task_' repectively.</p>

      <p>For example, task recipe <code>clean</code> is a recipe to delete '*.o' files and is not combined to file 'clean'. Also symbolic recipe <code>all</code> is a recipe to call recipe of 'hello' and is not combined to file 'all'.</p><a name="Kookbook5.py" id="Kookbook5.py"></a>

      <div class="program_caption">
        Kookbook.py: Symbolic recipes
      </div>
      <pre class="program">
## file recipe
@product("hello")
@ingreds("hello.o")
def file_hello(c):
    """generates hello command"""
    system(c%"gcc -g -o $(product) $(ingred)")
    # or system("gcc -g -o %s %s" % (c.product, c.ingred))
    # or system("gcc -g -o %s %s" % (c.product, c.ingreds[0]))

## file recipe
@product("*.o")        # or @product(re.compile(r'^(.*?)\.o$'))
@ingreds("$(1).c", if_exists("$(1).h"))
def file_ext_o(c):
    """compile '*.c' and '*.h'"""
    system(c%"gcc -g -c $(1).c")
    # or system("gcc -g -c %s.c" % c.m[1])
    # or system("gcc -g -c %s" % c.ingred)

## task recipe
@product("clean")      # omittable
def <strong>task_clean</strong>(c):
    """remove '*.o' files"""
    rm_f("*.o")

## task recipe
@product("all")        # omittable
@ingreds("hello")
def <strong>task_all</strong>(c):
    """create all files"""
    pass
</pre>

      <p>You can omit '<code>@product("all")</code>' because pyKook will guess product name (= 'all') from recipe function name (= 'task_all').</p>

      <p>'<code>pykook -l</code>' will display task recipes and file recipes.</p><a name="Kookbook.py5.symrecipe.result" id="Kookbook.py5.symrecipe.result"></a>

      <div class="terminal_caption">
        command-line example
      </div>
      <pre class="terminal">
sh&gt; pykook -l
Properties:

Task recipes:
  clean               : remove by-products
  all                 : cook all products

File recipes:
  hello               : generates hello command
  *.o                 : compile '*.c' and '*.h'

(Tips: you can set 'kook_default_product' variable in your kookbook.)

sh&gt; pykook all
### *** hello.o (func=file_ext_o)
$ gcc -g -c hello.c
### ** hello (func=file_hello)
$ gcc -g -o hello hello.o
### * all (func=task_all)

sh&gt; pykook clean
### * clean (func=task_clean)
$ rm -f *.o

sh&gt; ls -F
Kookbook.py    hello*    hello.c    hello.h
</pre>

      <p>pyKook have several well-known task name. Task recipes which product name is in the following list will be got pubilic automatically. For example, if you have defined 'all' task recipe, it will be displayed by '<code>pykook -l</code>' even when recicpe function doesn't have document.</p>

      <dl class="dl3" compact>
        <dt class="dt3"><b>all</b></dt>

        <dd class="dd3">create all products</dd>

        <dt class="dt3"><b>clean</b></dt>

        <dd class="dd3">remove by-products</dd>

        <dt class="dt3"><b>clear</b></dt>

        <dd class="dd3">remove all products and by-products</dd>

        <dt class="dt3"><b>deploy</b></dt>

        <dd class="dd3">deploy products</dd>

        <dt class="dt3"><b>config</b></dt>

        <dd class="dd3">configure</dd>

        <dt class="dt3"><b>setup</b></dt>

        <dd class="dd3">setup</dd>

        <dt class="dt3"><b>install</b></dt>

        <dd class="dd3">install products</dd>

        <dt class="dt3"><b>test</b></dt>

        <dd class="dd3">do test</dd>
      </dl><br>
      <a name="cookbook-default-product" id="cookbook-default-product"></a>

      <h3 class="section2">Default Product</h3>

      <p>If you set <code>kook_default_product</code> variable, pykook command will use it as default product.</p><a name="Kookbook6.yaml" id="Kookbook6.yaml"></a>

      <div class="program_caption">
        Kookbook.py.yaml: specify default product name
      </div>
      <pre class="program">
## global variables
basename = 'hello'
command  = basename
<strong>kook_default_product = 'all'</strong>     # default product name

## file recipe
@product(command)
@ingreds(basename + ".o")
def file_hello(c):
    """generates hello command"""
    system(c%"gcc -g -o $(product) $(ingred)")
    # or system("gcc -g -o %s %s" % (c.product, c.ingred))
    # or system("gcc -g -o %s %s" % (c.product, c.ingreds[0]))

## file recipe
@product("*.o")        # or @product(re.compile(r'^(.*?)\.o$'))
@ingreds("$(1).c", if_exists("$(1).h"))
def file_ext_o(c):
    """compile '*.c' and '*.h'"""
    system(c%"gcc -g -c $(1).c")
    # or system("gcc -g -c %s.c" % c.m[1])
    # or system("gcc -g -c %s" % c.ingred)

## task recipe
def task_clean(c):
    """remove '*.o' files"""
    rm_f("*.o")

## task recipe
@ingreds(command)
def task_all(c):
    """create all files"""
    pass
</pre>

      <p>If you specify <code>kook_default_product</code>, you can omit target product name in commad-line.</p><a name="Kookbook.py6.default.result" id="Kookbook.py6.default.result"></a>

      <div class="terminal_caption">
        command-line example
      </div>
      <pre class="terminal">
sh&gt; pykook           # you can omit target product name
### *** hello.o (func=file_ext_o)
$ gcc -g -c hello.c
### ** hello (func=file_hello)
$ gcc -g -o hello hello.o
### * all (func=task_all)
</pre><br>
      <a name="cookbook-props" id="cookbook-props"></a>

      <h3 class="section2">Properties</h3>

      <p>Property is a global variable which value can be overwrited in command-line option.</p>

      <p>Property is defined by <code>prop()</code> function. It takes property name and default value as arguments.</p><a name="Kookbook6.py" id="Kookbook6.py"></a>

      <div class="program_caption">
        Kookbook.py: properties
      </div>
      <pre class="program">
## global variables (not properties)
basename = 'hello'
kook_default_product = 'all'

## properties
CC       = <strong>prop('CC', 'gcc')</strong>
CFLAGS   = <strong>prop('CFLAGS', '-g -O2')</strong>
command  = <strong>prop('command', basename)</strong>

## recipes
@product(command)
@ingreds(basename + ".o")
def file_command(c):
    system(c%"$(CC) $(CFLAGS) -o $(product) $(ingred)")

@product("*.o")
@ingreds("$(1).c", if_exists("$(1).h"))
def file_ext_o(c):
    system(c%"$(CC) $(CFLAGS) -c $(ingred)")

def task_clean(c):
    """remove '*.o' files"""
    rm_f("*.o")

@ingreds(command)
def task_all(c):
    pass
</pre>

      <p>Properties are shown when command-line option '-l' is specified.</p><a name="Kookbook.py6.props2.result" id="Kookbook.py6.props2.result"></a>

      <div class="terminal_caption">
        command-line example
      </div>
      <pre class="terminal">
sh&gt; pykook <strong>-l</strong>
Properties:
  <strong>CC                  : 'gcc'</strong>
  <strong>CFLAGS              : '-g'</strong>
  <strong>command             : 'hello'</strong>

Task recipes:
  all                 : cook all products

File recipes:

(Tips: you can set 'kook_default_product' variable in your kookbook.)
</pre>

      <p>If you don't specify any property values in command-line, default values are used.</p><a name="Kookbook.py6.props3.result" id="Kookbook.py6.props3.result"></a>

      <div class="terminal_caption">
        command-line example
      </div>
      <pre class="terminal">
sh&gt; pykook all
### *** hello.o (func=file_ext_o)
$ gcc <strong>-g</strong> -c hello.c
### ** hello (func=file_command)
$ gcc <strong>-g</strong> -o <strong>hello</strong> hello.o
### * all (func=task_all)
</pre>

      <p>If you specify property values in command-line, that values are used instead of default values.</p><a name="Kookbook.py6.props4.result" id="Kookbook.py6.props4.result"></a>
      <pre class="terminal">
sh&gt; pykook <strong>--command=foo</strong> <strong>--CFLAGS='-g -O2 -Wall'</strong> all
### *** hello.o (func=file_ext_o)
$ gcc <strong>-g -O2 -Wall</strong> -c hello.c
### ** foo (func=file_command)
$ gcc <strong>-g -O2 -Wall</strong> -o <strong>foo</strong> hello.o
### * all (func=task_all)
</pre>

      <p>Property file is another way to specify properties. If you have create property file 'Property.py' in current directory, pykook command reads it and set property values automatically.</p><a name="Kookbook6.props5.properties" id="Kookbook6.props5.properties"></a>

      <div class="program_caption">
        Properties.py
      </div>
      <pre class="program">
CFLAGS = '-g -O2 -Wall'
command = 'foo'
</pre>

      <p>Don't forget to write <code>prop('prop-name', 'default-value')</code> in your cookbook even when property file exists.</p>

      <p>Result of <code>pykook -l</code> will be changed when property file exists.</p><a name="Kookbook.py6.props5.result" id="Kookbook.py6.props5.result"></a>
      <pre class="terminal">
sh&gt; pykook -l
Properties:
  CC                  : 'gcc'
  CFLAGS              : <strong>'-g -O2 -Wall'</strong>
  command             : <strong>'foo'</strong>

Task recipes:
  all                 : cook all products

File recipes:

(Tips: you can override properties with '--propname=propvalue'.)
</pre><br>
      <a name="cookbook-materials" id="cookbook-materials"></a>

      <h3 class="section2">Materials</h3>

      <p>There is an exception in any case. Assume that you have a file 'optparse.o' which is supplied by other developer and no source. pyKook will try to find 'optparse.c' and failed in the result.</p>

      <p>Using 'kook_materials' variable, you can tell pyKook that 'optparse.o' is not a product .</p><a name="Kookbook8.py" id="Kookbook8.py"></a>

      <div class="program_caption">
        Kookbook.py: materials
      </div>
      <pre class="program">
## global variables (not properties)
basename = 'hello'
kook_default_product = 'all'
<strong>kook_materials = ['optparse.o', ]</strong>   # specify materials

## properties
CC       = prop('CC', 'gcc')
CFLAGS   = prop('CFLAGS', '-g -O2')
command  = prop('command', basename)

## recipes
@product(command)
@ingreds("hello.o", <strong>"optparse.o"</strong>)
def file_command(c):
    system(c%"$(CC) $(CFLAGS) -o $(product) <strong>$(ingreds)</strong>")

@product("*.o")
@ingreds("$(1).c", if_exists("$(1).h"))
def file_ext_o(c):
    system(c%"$(CC) $(CFLAGS) -c $(ingred)")

@ingreds(command)
def task_all(c):
    pass
</pre>

      <p>In this example:</p>

      <ul type="disc">
        <li>'hello.o' will be compiled from 'hello.c'.</li>

        <li>'optparse.o' will not be compiled because it is specified as material.</li>
      </ul><a name="Kookbook8.materials" id="Kookbook8.materials"></a>

      <div class="terminal_caption">
        command-line example
      </div>
      <pre class="terminal">
sh&gt; pykook all
### *** hello.o (func=file_ext_o)            # only hello.o is compiled
$ gcc -g -O2 -c hello.c
### ** hello (func=file_command)
$ gcc -g -O2 -o hello hello.o optparse.o
### * all (func=task_all)
</pre><br>
      <a name="cookbook-spices" id="cookbook-spices"></a>

      <h3 class="section2">Command-line options for recipe</h3>

      <p>You can specify command-line options for certain recipes by <code>@spices()</code> decorator.</p><a name="Kookbook9.py" id="Kookbook9.py"></a>

      <div class="program_caption">
        Kookbook.py: command-line options for recipes
      </div>
      <pre class="program">
## global variables (not properties)
basename = 'hello'
kook_default_product = 'all'
<strong>kook_materials = ['optparse.o', ]</strong>   # specify materials

## properties
CC       = prop('CC', 'gcc')
CFLAGS   = prop('CFLAGS', '-g -O2')
command  = prop('command', basename)

## recipes
@product(command)
@ingreds("hello.o", <strong>"optparse.o"</strong>)
def file_command(c):
    system(c%"$(CC) $(CFLAGS) -o $(product) <strong>$(ingreds)</strong>")

@product("*.o")
@ingreds("$(1).c", if_exists("$(1).h"))
def file_ext_o(c):
    system(c%"$(CC) $(CFLAGS) -c $(ingred)")

@ingreds(command)
def task_all(c):
    pass

@ingreds(command)
<strong>@spices("-d dir: directory to install (default '/usr/local/bin')",</strong>
        <strong>"--command=command: command name (default '%s')" % command)</strong>
def task_install(c, <strong>*args</strong>, <strong>**kwargs</strong>):
    <strong>opts, rests = kwargs, args</strong>
    dir = opts.get('d', '/usr/local/bin')  # get option value
    cmd = opts.get('command', command)     # get option value
    system(c%"sudo cp $(command) $(dir)/$(cmd)")   # or install command
</pre>

      <p>Command-line options of recipes are displayed by '-l' or '-L' option.</p><a name="Kookbook9.spices1.result" id="Kookbook9.spices1.result"></a>

      <div class="terminal_caption">
        command-line example
      </div>
      <pre class="terminal">
sh&gt; pykook -l
Properties:
  CC                  : 'gcc'
  CFLAGS              : '-g -O2'
  command             : 'hello'

Task recipes:
  all                 : cook all products
  install             : install product
    <strong>-d dir                directory to install (default '/usr/local/bin')</strong>
    <strong>--command=command     command name (default 'hello')</strong>

File recipes:

kook_default_product: all

(Tips: 'c%"gcc $(ingreds[0])"' is more natural than '"gcc %s" % c.ingreds[0]'.)
</pre>

      <p>You can specify command-line options for the recipe.</p><a name="Kookbook9.spices2.result" id="Kookbook9.spices2.result"></a>
      <pre class="terminal">
sh&gt; pykook install <strong>-d /opt/local/bin --command=hellow</strong>
### * install (func=task_install)
$ sudo cp hello /opt/local/bin/hellow
Password: *******
</pre>

      <p>This feature can replace many small scripts with pyKook.</p>

      <p>The following is an example to show styles of <code>@spices</code> arguments.</p>

      <div class="program_caption">
        Kookbook.py: example of @spices()
      </div>
      <pre class="program">
@spices("-h:      help",            # short opts (no argument)
        "-f file: filename",        # short opts (argument required)
        "-d[N]:   debug level",     # short opts (optional argument)
        "--help:  help",            # long opts (no argument)
        "--file=file: filename",    # long opts (argument required)
        "--debug[=N]: debug level", # long opts (optional argument)
        )
def task_echo(c, *args, **kwargs):
    """test of @spices"""
    opts, rests = kwargs, args
    print "opts:", repr(opts)
    print "rests:", repr(rests)
</pre>

      <div class="terminal_caption">
        result
      </div>
      <pre class="terminal">
sh&gt; pykook -L
Properties:

Task recipes:
  echo                : test of @spices
    -h                    help
    -f file               filename
    -d[N]                 debug level
    --help                help
    --file=file           filename
    --debug[=N]           debug level

File recipes:

(Tips: you can override properties with '--propname=propvalue'.)

sh&gt; pykook echo -f hello.c -d99 --help --debug AAA BBB
### * echo (func=task_echo)
opts: {'debug': True, 'help': True, 'd': 99, 'f': 'hello.c'}
rests: ('AAA', 'BBB')
</pre><br>
      <br>
      <a name="topic" id="topic"></a>

      <h2 class="section1">Other features</h2><a name="topc-debug-mode" id="topc-debug-mode"></a>

      <h3 class="section2">Debug mode</h3>

      <p>Command-line option <code>-D</code> or <code>-D2</code> turn on debug mode and and debug message will be displayed. <code>-D2</code> is higher debug level than <code>-D</code>.</p>

      <div class="terminal_caption">
        example of <code>-D</code>
      </div>
      <pre class="terminal">
sh&gt; pykook -D hello 
*** debug: + begin hello
*** debug: ++ begin hello.o
*** debug: +++ material hello.c
*** debug: +++ material hello.h
*** debug: ++ create hello.o (func=file_hello_o)
### ** hello.o (func=file_hello_o)
$ gcc -g -c hello.c
*** debug: ++ end hello.o (content changed)
*** debug: + create hello (func=file_hello)
### * hello (func=file_hello)
$ gcc -g -o hello hello.o
*** debug: + end hello (content changed)
</pre><br>
      <a name="topic-short-command" id="topic-short-command"></a>

      <h3 class="section2">Short command</h3>

      <p>pyKook provides <code>kk</code> command which is the same as <code>pykook</code> command, because <code>pykook</code> is too long to type many times :)</p><br>
      <a name="topic-forcedly" id="topic-forcedly"></a>

      <h3 class="section2">Invoke Recipes Forcedly</h3>

      <p>Command-line option '-F' invokes recipes forcedly. In the other words, timestamp of files are ignored when '-F' is specified.</p><br>
      <a name="topic-nestedarray" id="topic-nestedarray"></a>

      <h3 class="section2">Nested Array</h3>

      <p>You can specify not only filenames but also list of filenames as ingredient <code>@ingreds()</code>. pyKook flatten arguments of <code>@ingreds()</code> automatically.</p><a name="Kookbook13.py" id="Kookbook13.py"></a>

      <div class="program_caption">
        Kookbook.py: specify list of filenames
      </div>
      <pre class="program">
from glob import glob
sources = glob("*.c")
objects = [ s.replace(".c", ".o") for s in sources ]

@product("hello")
@ingreds(<strong>objects</strong>)    # specify list of filenams
def task_hello(c):
    system(c%"gcc -o $(product) $(<strong>ingreds</strong>)")  # expanded to filenames

@product("*.o")
@ingreds("$(1).c")
def file_ext_o(c):
    sysytem(c%"gcc -c $(ingred)")
</pre><br>
      <br>
      <a name="trouble" id="trouble"></a>

      <h2 class="section1">Trouble Shooting</h2><a name="trouble-product-not-created" id="trouble-product-not-created"></a>

      <h3 class="section2">xxx: product not created (in file_xxx())</h3>

      <p>Q: I got the "xxx: product not created (in file_xxx())." error.</p>

      <p>A: Define 'task_xxx()' instead of 'file_xxx()'.</p>
      <pre class="program">
## Use 'task_clean()' instead of 'file_clean()'
def file_clean(c):   #=&gt; KookRecipeError: clean: product not created (in file_clean()).
    rm_f("*.o")
</pre><br>
      <a name="trouble-cant-find-any-recipe-to-produce" id="trouble-cant-find-any-recipe-to-produce"></a>

      <h3 class="section2">*.c: can't find any recipe to produce.</h3>

      <p>Q: I got the "*.c: can't find any recipe to produce." error.</p>

      <p>A: Use "$(1).c" instead of "*.c" in @ingreds() argument.</p>
      <pre class="program">
## Use "$(1).c" instead of "*.c"
@product("*.o")
@ingreds("*.c")  #=&gt; KookRecipeError: *.c: can't find any recipe to produce.
def file_ext_o(c):
    system(c%"gcc -c $(ingred)")
</pre><br>
      <a name="trouble-ingred-command-not-found" id="trouble-ingred-command-not-found"></a>

      <h3 class="section2">sh: line 1: ingred: command not found</h3>

      <p>Q: I got the "sh: line 1: ingred: command not found" error.</p>

      <p>A: Add "c%" at the beginning of command string.</p>
      <pre class="program">
    ## Don't forget to add "c%" if you want to use "$()".
    @product("*.o")
    @ingreds("$(1).c")
    def file_ext_o(c):
        system("gcc -c $(ingred)")
            #=&gt; KookCommandError: sh: line 1: ingred: command not found" error.
</pre><br>
      <br>
      <a name="refs" id="refs"></a>

      <h2 class="section1">References</h2><a name="refs-filesystem" id="refs-filesystem"></a>

      <h3 class="section2">Filesystem Functions</h3>

      <p>The following functions are available in 'method*:' part of recipes.</p>

      <dl class="dl3">
        <dt class="dt3"><b>system(<em>cmmand-string</em>)</b></dt>

        <dd class="dd3">
          Execute <em>command-string</em>. If command status is not zero then exception is raised.
          <pre class="program">
system("gcc hello.c")
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>system_f(<em>command-string</em>)</b></dt>

        <dd class="dd3">Execute <em>command-string</em>. Command statuis is ignored.</dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>echo(<em>string</em>)</b></dt>

        <dd class="dd3">
          Echo <em>string</em>. Newline is printed.
          <pre class="program">
echo "OK."
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>echo_n(<em>string</em>)</b></dt>

        <dd class="dd3">
          Echo <em>string</em>. Newline is not printed.
          <pre class="program">
echo_n "Enter your name: "
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>cd(<em>dir</em>)</b></dt>

        <dd class="dd3">
          Change directory. Return current directory.
          <pre class="program">
cwd = cd("build")
...
cd(cwd)              # back to current directry
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>chdir(<em>dir</em>)</b></dt>

        <dd class="dd3">
          Change current directory temporary. If this is used with Python's with-statement, current directory will be backed automatically.
          <pre class="program">
with chdir("build") as d:
   ...     # into "build" directory
# back to current directry automatically
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>mkdir(<em>path</em>)</b></dt>

        <dd class="dd3">
          Make directory.
          <pre class="program">
mkdir("lib")
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>mkdir_p(<em>path</em>)</b></dt>

        <dd class="dd3">
          Make directory. If parent directory is not exist then it is created automatically.
          <pre class="program">
mkdir_p("foo/bar/baz")
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>rm(<em>path</em>[, <em>path2</em>, ...])</b></dt>

        <dd class="dd3">
          Remove files.
          <pre class="program">
rm('*.html', '*.txt')
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>rm_r(<em>path</em>[, <em>path2</em>, ...])</b></dt>

        <dd class="dd3">
          Remove files or directories recursively.
          <pre class="program">
rm_r('*')
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>rm_f(<em>path</em>[, <em>path2</em>, ...])</b></dt>

        <dd class="dd3">
          Remove files forcedly. No errors reported even if <em>path</em> doesn't exist.
          <pre class="program">
rm_f('*.html', '*.txt')
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>rm_rf(<em>path</em>[, <em>path2</em>, ...])</b></dt>

        <dd class="dd3">
          Remove files or directories forcedly. No errors reported even if <em>path</em> doesn't exist.
          <pre class="program">
rm_rf('*')
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>touch(<em>path</em>[, <em>path2</em>, ...])</b></dt>

        <dd class="dd3">
          Touch files or directories. If <em>path</em> doesn't exist then empty file is created.
          <pre class="program">
touch('*.c')
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>cp(<em>file1</em>, <em>file2</em>)</b></dt>

        <dd class="dd3">
          Copy <em>file1</em> to <em>file2</em>.
          <pre class="program">
cp('foo.txt', 'bar.txt')
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>cp(<em>file</em>, <em>file2</em>, ..., <em>dir</em>)</b></dt>

        <dd class="dd3">
          Copy <em>file</em> to <em>dir</em>.
          <pre class="program">
cp('*.txt', '*.html', 'dir')
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>cp_r(<em>path1</em>, <em>path2</em>)</b></dt>

        <dd class="dd3">
          Copy <em>path1</em> to <em>path2</em> recursively.
          <pre class="program">
cp_r('dir1', 'dir2')
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>cp_r(<em>path</em>, <em>path2</em>, ..., <em>dir</em>)</b></dt>

        <dd class="dd3">
          Copy <em>path</em> to <em>dir</em> recursively. Directory <em>dir</em> must exist.
          <pre class="program">
cp_r('lib', 'doc', 'test', 'dir')
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>cp_p(<em>file1</em>, <em>file2</em>)</b></dt>

        <dd class="dd3">
          Copy <em>file1</em> to <em>file2</em>. Timestams is preserved.
          <pre class="program">
cp_p('foo.txt', 'bar.txt')
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>cp_p(<em>file</em>, <em>file2</em>, ..., <em>dir</em>)</b></dt>

        <dd class="dd3">
          Copy <em>file</em> to <em>dir</em>. Timestams is preserved. Directory <em>dir</em> must exist.
          <pre class="program">
cp_p('*.txt', '*.html', 'dir')
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>cp_pr(<em>path1</em>, <em>path2</em>)</b></dt>

        <dd class="dd3">
          Copy <em>path1</em> to <em>path2</em> recursively. Timestams is preserved.
          <pre class="program">
cp_pr('lib', 'lib.bkup')
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>cp_pr(<em>path</em>, <em>path2</em>, ..., <em>dir</em>)</b></dt>

        <dd class="dd3">
          Copy <em>path</em> to <em>dir</em> recursively. Directory <em>dir</em> must exist. Timestams is preserved.
          <pre class="program">
cp_pr('lib/**/*.rb', 'test/**/*.rb', 'tmpdir')
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>mv(<em>file1</em>, <em>file2</em>)</b></dt>

        <dd class="dd3">
          Rename <em>file1</em> to <em>file2</em>.
          <pre class="program">
mv('foo.txt', 'bar.txt')
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>mv(<em>path</em>, <em>path2</em>, ..., <em>dir</em>)</b></dt>

        <dd class="dd3">
          Move <em>path</em> to <em>dir</em>.
          <pre class="program">
mv('lib/*.rb', 'test/*.rb', 'tmpdir')
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>store(<em>path</em>, <em>path2</em>, ..., <em>dir</em>)</b></dt>

        <dd class="dd3">
          Copy <em>path</em> (files or directories) to <em>dir</em> with keeping path-structure.
          <pre class="program">
store("lib/**/*.py", "doc/**/*.{html,css}", "dir")
## ex.
##   "lib/kook/__init__.py"  is copied into "dir/lib/kook/__init__.py"
##   "lib/kook/utils.py"     is copied into "dir/lib/kook/utils.py"
##   "lib/kook/main.py"      is copied into "dir/lib/kook/main.py"
##   "doc/users-guide.html"  is copied into "dir/doc/users-guide.html"
##   "doc/docstyle.css"      is copied into "dir/doc/docstyle.css"
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>store_p(<em>path</em>, <em>path2</em>, ..., <em>dir</em>)</b></dt>

        <dd class="dd3">
          Copy <em>path</em> (files or directories) to <em>dir</em> with keeping path-structure. Timestamp is preserved.
          <pre class="program">
store_p("lib/**/*.py", "doc/**/*.html", "dir")
</pre>
        </dd>
      </dl>

      <dl class="dl3">
        <dt class="dt3"><b>edit(<em>path</em>, <em>path2</em>, ..., by=replacer)</b></dt>

        <dd class="dd3">
          Edit file content. Keyword argument 'by' should be a callable to edit content, or list of tuples of replacing pattern and string.
          <pre class="program">
## edit by list of regular expression and string
replacer = [
    (r'\$Release\$', "1.0.0"),
    (r'\$Copyright\$', "copyright(c) 2008 kuwata-lab.com"),
]
edit("lib/**/*.py", "doc/**/*.{html,css}", by=replacer)
## edit by function
def replacer(s):
    s = s.replace('$Release$',   "1.0.0", s)
    s = s.replace('$Copyright$', "copyright(c) 2008 kuwata-lab.com", s)
    return s
edit("lib/**/*.py", "doc/**/*.{html,css}", by=replacer)
</pre>
        </dd>
      </dl>

      <p>The above functions can take lists or tuples as file or directory names. (If argument is list or tuple, it is flatten by <code>kook.utils.flatten()</code>.)</p>

      <p>For example, the following code is available.</p>
      <pre class="program">
## copy all files into dir
files = ['file1.txt', 'file2.txt', 'file3.txt']
cp(files, 'dir')
</pre>

      <p>The following file pattern is available.</p>

      <dl class="dl3">
        <dt class="dt3"><b><code>*</code></b></dt>

        <dd class="dd3">Matches sequence of any character.</dd>

        <dt class="dt3"><b><code>?</code></b></dt>

        <dd class="dd3">Matches a character.</dd>

        <dt class="dt3"><b><code>{<em>a</em>,<em>b</em>,<em>c</em>}</code></b></dt>

        <dd class="dd3">Matches <em>a</em> or <em>b</em> or <em>c</em>.</dd>

        <dt class="dt3"><b><code>**/</code></b></dt>

        <dd class="dd3">Matches directory recursively.</dd>
      </dl><br>
      <br>
    </div>
  </blockquote>
</body>
</html>
